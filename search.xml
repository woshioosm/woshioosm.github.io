<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>docker 学习</title>
    <url>/2020/12/23/docker/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>对部分使用命令进行记录</p>
<a id="more"></a>


<h1 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h1><ul>
<li>docker run<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-d (--detach 启动守护容器,后台运行)</span><br><span class="line">-i (--interactive 保持标准输入流)</span><br><span class="line">-t (--tty 为容器分配一个虚拟终端)</span><br><span class="line">-e (--env 传递环境变量)</span><br><span class="line">-v (挂载数据卷 -v 存储卷地址:容器内地址:读写权限)</span><br><span class="line">--name (指定命名空间)</span><br><span class="line">--read-only （只读文件系统）</span><br><span class="line">--rm 容器进入退出状态时，被自动删除</span><br><span class="line">docker run -it sth &#x2F;bin&#x2F;sh</span><br></pre></td></tr></table></figure></li>
<li>docker create (创建但是不启动)</li>
<li>docker ps</li>
<li>docker rename old new</li>
<li>docker start/stop/restart sth</li>
<li>docker rm sth </li>
<li>docker logs sth -f</li>
<li>docker exec (在运行的容器中运行额外的进程)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec sth ps</span><br><span class="line">docker exec -it sth sh</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="持久化容器"><a href="#持久化容器" class="headerlink" title="持久化容器"></a>持久化容器</h2><h3 id="自动重启容器"><a href="#自动重启容器" class="headerlink" title="自动重启容器"></a>自动重启容器</h3><p>–start</p>
<ul>
<li>从不重启（默认）</li>
<li>检测到故障时尝试重启 on-failure</li>
<li>在容器非正常退出时重启容器，最多重启n次  on-failure:n</li>
<li>检测到故障时，在一段预定的时间后重新开始尝试重启 </li>
<li>不管任何条件，始终重新启动容器 always </li>
<li>在容器退出时总是重启容器，但是不考虑在Docker守护进程启动时就已经停止了的容器 unless-stopped</li>
</ul>
<h3 id="维持容器的运行状态"><a href="#维持容器的运行状态" class="headerlink" title="维持容器的运行状态"></a>维持容器的运行状态</h3><ul>
<li>supervisord</li>
<li>init</li>
<li>systemd</li>
<li>runit</li>
<li>upstart</li>
</ul>
<h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><p>仓库是一个有名字的镜像桶，名字类似与URL。仓库名由该镜像所在的主机，拥有该镜像的用户账户和一个简短的名称组成。</p>
<h2 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h2><ul>
<li>发布镜像<ul>
<li>命令行</li>
<li>Dockerfile</li>
</ul>
</li>
<li>docker search sth</li>
</ul>
<h1 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h1><h2 id="绑定挂载卷"><a href="#绑定挂载卷" class="headerlink" title="绑定挂载卷"></a>绑定挂载卷</h2><h2 id="Docker管理卷"><a href="#Docker管理卷" class="headerlink" title="Docker管理卷"></a>Docker管理卷</h2><h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><h2 id="Closed容器-只有回环接口"><a href="#Closed容器-只有回环接口" class="headerlink" title="Closed容器:只有回环接口"></a>Closed容器:只有回环接口</h2><ul>
<li>–net none</li>
<li>容器外的程序无法连接到该网络接口</li>
<li>容器内的程序无法访问到容器外的网络<h2 id="Bridged容器：私有接口和回环接口"><a href="#Bridged容器：私有接口和回环接口" class="headerlink" title="Bridged容器：私有接口和回环接口"></a>Bridged容器：私有接口和回环接口</h2></li>
<li>–net bridge</li>
<li>最常见的网络容器原型<ul>
<li>私有的本地回环接口</li>
<li>私有接口通过网桥连接到主机的其他容器</li>
</ul>
</li>
<li>自定义命名解析<ul>
<li>–hostname xx   会在该容器的DNS中添加一条记录，这条记录会将提供的主机名映射成该容器的桥接ip地址</li>
<li>–dns 8.8.8.8  用来指定一个或者多个DNS服务器</li>
<li>–dns-search xx  指定一个DNS查找域，这个查找域就像host名的一个默认后缀，在查询时，任何不包括已知顶级域名的主机名都会自动加上该后缀名（可以多次添加）<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --dns-search docker.com xxx nslookup registry.hub   &#x2F;&#x2F; 会解析registry.hub.docker.com的ip</span><br></pre></td></tr></table></figure></li>
<li>–add-host 自定义从主机名到ip地址的映射关系<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --add-host test:10.10.10.255 sth nslookup test</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>开放对容器的访问<ul>
<li>默认的网络拓扑结构没有提供任何从主机外部接口到容器接口的路由</li>
<li>-p (–publish选项) 在主机网络栈上的端口和容器端口之间创建映射关系<ul>
<li>docker run -p 3333  将容器端口绑定到所有主机接口的一个动态端口上</li>
<li>docker run -p 3333:3333 将一个具体的容器端口绑定到所有主机接口的某一个具体端口上</li>
<li>docker run -p 192.168.0.32::2222  将容器绑定到拥有指定ip地址的主机接口的动态端口上</li>
<li>docker run -p 192.168.0.32:1111:1111  将容器端口绑定到拥有指定ip的主机接口的的一个具体端口上</li>
</ul>
</li>
<li>-P (–publish-all选项)  将容器的端口都暴露出去<ul>
<li>–expose 将端口添加到-P 选项的端口列表中 </li>
</ul>
</li>
<li>docker port sth 查看端口映射</li>
</ul>
</li>
<li>跨容器通信<ul>
<li>所有的本地bridged 容器都是在同一个桥接网络上，并且默认情况下能够互相通信</li>
<li>默认情况下，容器对本地的其他容器是完全开放的</li>
<li>可以选择关闭容器之间的网络连接（如多租户情况下）<ul>
<li>–ice=false 除非被显式允许的流量，否则任何从容器到容器的网络流量都会被主机的防火墙阻止</li>
</ul>
</li>
</ul>
</li>
<li>修改网桥接口的配置<ul>
<li>定义网桥的地址和子网</li>
<li>定义容器所能获取的IP地址的范围</li>
<li>定义最大传输单元（MTU）</li>
</ul>
</li>
</ul>
<h2 id="Joined容器"><a href="#Joined容器" class="headerlink" title="Joined容器"></a>Joined容器</h2><h2 id="Open容器"><a href="#Open容器" class="headerlink" title="Open容器"></a>Open容器</h2>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/09/16/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
 <a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Testing</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>others</tag>
      </tags>
  </entry>
  <entry>
    <title>基于github 搭建hexo+next博客</title>
    <url>/2020/09/18/hexo-next/</url>
    <content><![CDATA[<h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><ol>
<li>搭建本地的调试环境</li>
<li>基于github 发布hexo+next风格的博客</li>
<li>基于github action， 进行自动的编译和发布</li>
</ol>
<a id="more"></a>

<h2 id="基础环境安装"><a href="#基础环境安装" class="headerlink" title="基础环境安装"></a>基础环境安装</h2><ul>
<li>安装git</li>
<li>安装nodejs</li>
<li>安装npm</li>
</ul>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init blog</span><br><span class="line">$ <span class="built_in">cd</span> blog</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure>

<h2 id="安装next主题"><a href="#安装next主题" class="headerlink" title="安装next主题"></a>安装next主题</h2><p>下载netx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> theme</span><br><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/hexo-theme-next</span><br></pre></td></tr></table></figure>
<p>修改blog目录下的_config.yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>
<p>本地部署</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>本地浏览</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">localhost:4000</span><br></pre></td></tr></table></figure>

<h2 id="添加功能"><a href="#添加功能" class="headerlink" title="添加功能"></a>添加功能</h2><h3 id="添加“标签”-”分类”"><a href="#添加“标签”-”分类”" class="headerlink" title="添加“标签” ,”分类”"></a>添加“标签” ,”分类”</h3><ol>
<li>用命令生成文件<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">&quot;tags&quot;</span></span><br><span class="line">$ hexo new page <span class="string">&quot;categories&quot;</span></span><br></pre></td></tr></table></figure></li>
<li>打开生成的index.md文件，title和date是默认生成的，增加type即可<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">title</span>: <span class="string">tags</span></span><br><span class="line"><span class="attr">date</span>: <span class="string">2019-06-25 19:16:17</span></span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;tags&quot;</span></span><br><span class="line"><span class="attr">---</span></span><br><span class="line"> </span><br><span class="line"><span class="attr">---</span></span><br><span class="line"><span class="attr">title</span>: <span class="string">categories</span></span><br><span class="line"><span class="attr">date</span>: <span class="string">2019-06-25 19:16:17</span></span><br><span class="line"><span class="attr">type</span>: <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">---</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="添加“搜索”"><a href="#添加“搜索”" class="headerlink" title="添加“搜索”"></a>添加“搜索”</h3><ol>
<li>在blog目录下安装插件 (接下来的自动发布 还需要加入到workflow中)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure></li>
<li>在blog的_config.yml 最后添加<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>新建自己的github.io 项目， 将工程推送到github上</p>
<blockquote>
<p>next目录应该是一个引用，建议自己拷贝一份引入</p>
</blockquote>
<h2 id="CNAME"><a href="#CNAME" class="headerlink" title="CNAME"></a>CNAME</h2><p>如果自己的项目有域名解析关联，建立CNAME文件，文件中写入你的域名，放置在source目录中</p>
<h2 id="自动发布"><a href="#自动发布" class="headerlink" title="自动发布"></a>自动发布</h2><ul>
<li>通过github action功能，每次上传新文件或者修改样式，都会重新编译生成新的页面</li>
<li>建议建立一个新的repo或者分支作为发布的目标</li>
<li>这里将master 设置为发布的分支， dev为维护blog源码和博客md的分支</li>
</ul>
<p>操作流程如下：</p>
<ol>
<li>建立一对公私钥，使得自动部署有权限发布<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -f ~&#x2F;.ssh&#x2F;GitHub-actions-deploy</span><br></pre></td></tr></table></figure></li>
<li>在 github-Settings-Deploy keys 中填入刚才生成的pub文件内容</li>
<li>在github-Settings-Secrets 中填入刚才生成的私钥文件，secret的name命名为HEXO_DEPLOY_PRI（随意，但需要和后文的workflow匹配）</li>
<li>blog目录的_config.yml中添加(指定好要部署的位置)<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@xxxxxx</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure></li>
<li>github中打开工程的Actions-new workfolw （建立在dev分支中）<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">CI</span></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line"></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Checkout</span> <span class="string">source</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/checkout@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">ref:</span> <span class="string">dev</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Use</span> <span class="string">Node.js</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">uses:</span> <span class="string">actions/setup-node@v1</span></span><br><span class="line">        <span class="attr">with:</span></span><br><span class="line">          <span class="attr">version:</span> <span class="string">$&#123;&#123;</span> <span class="string">matrix.node_version</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Setup</span> <span class="string">hexo</span></span><br><span class="line">        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">ACTION_DEPLOY_KEY:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.HEXO_DEPLOY_PRI</span> <span class="string">&#125;&#125;</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">~/.ssh/</span></span><br><span class="line">          <span class="string">echo</span> <span class="string">&quot;$ACTION_DEPLOY_KEY&quot;</span> <span class="string">&gt;</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">chmod</span> <span class="number">600</span> <span class="string">~/.ssh/id_rsa</span></span><br><span class="line">          <span class="string">ssh-keyscan</span> <span class="string">github.com</span> <span class="string">&gt;&gt;</span> <span class="string">~/.ssh/known_hosts</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.email</span> <span class="string">&quot;lujiahao0708@gmail.com&quot;</span></span><br><span class="line">          <span class="string">git</span> <span class="string">config</span> <span class="string">--global</span> <span class="string">user.name</span> <span class="string">&quot;lujiahao0708&quot;</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-cli</span> <span class="string">-g</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">https://github.com/CodeFalling/hexo-asset-image</span> <span class="string">--save</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">--save</span> <span class="string">hexo-deployer-git</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span> <span class="string">hexo-generator-searchdb</span> <span class="string">--save</span></span><br><span class="line">          <span class="string">npm</span> <span class="string">install</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span> <span class="string">deploy</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">clean</span></span><br><span class="line">          <span class="string">hexo</span> <span class="string">d</span></span><br></pre></td></tr></table></figure></li>
<li>保存这一切，每当发生push时，都会触发这个workflow 编译到我的master分支中</li>
<li>在settings首页的GitHub Pages中指定到master即可访问</li>
<li>配置可以参考<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;woshioosm&#x2F;woshioosm.github.io  （dev分支）</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title>ingress-nginx</title>
    <url>/2021/02/26/ingress-nginx/</url>
    <content><![CDATA[<h1 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h1><p>service暴露的三种方式ClusterIP、NodePort与LoadBalance，这几种方式都是在service的维度提供的，service的作用体现在两个方面，<br>对集群内部，它不断跟踪pod的变化，更新endpoint中对应pod的对象，提供了ip不断变化的pod的服务发现机制，对集群外部，他类似负载均衡器，<br>可以在集群内外部对pod进行访问。但是，单独用service暴露服务的方式，在实际生产环境中不太合适：</p>
<a id="more"></a>
<ul>
<li>ClusterIP的方式只能在集群内部访问。</li>
<li>NodePort方式的话，测试环境使用还行，当有几十上百的服务在集群中运行时，NodePort的端口管理是灾难。</li>
<li>LoadBalance方式受限于云平台，且通常在云平台部署ELB还需要额外的费用。<br>ingress可以简单理解为service的service，他通过独立的ingress对象来制定请求转发的规则，把请求路由到一个或多个service中。<br>这样就把服务与请求规则解耦了，可以从业务维度统一考虑业务的暴露，而不用为每个service单独考虑。</li>
</ul>
<h1 id="ingress与ingress-controller"><a href="#ingress与ingress-controller" class="headerlink" title="ingress与ingress-controller"></a>ingress与ingress-controller</h1><ul>
<li>ingress对象:指的是k8s中的一个api对象，一般用yaml配置。作用是定义请求如何转发到service的规则，可以理解为配置模板。</li>
<li>ingress-controller:具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发。</li>
</ul>
<h1 id="部署方式"><a href="#部署方式" class="headerlink" title="部署方式"></a>部署方式</h1><h2 id="Deployment-LoadBalancer模式的Service"><a href="#Deployment-LoadBalancer模式的Service" class="headerlink" title="Deployment+LoadBalancer模式的Service"></a>Deployment+LoadBalancer模式的Service</h2><p>如果要把ingress部署在公有云，那用这种方式比较合适。用Deployment部署ingress-controller，创建一个type为LoadBalancer的service关联这组pod。大部分公有云，都会为LoadBalancer的service自动创建一个负载均衡器，通常还绑定了公网地址。只要把域名解析指向该地址，就实现了集群服务的对外暴露。</p>
<h2 id="Deployment-NodePort模式的Service"><a href="#Deployment-NodePort模式的Service" class="headerlink" title="Deployment+NodePort模式的Service"></a>Deployment+NodePort模式的Service</h2><p>同样用deployment模式部署ingress-controller，并创建对应的服务，但是type为NodePort。这样，ingress就会暴露在集群节点ip的特定端口上。由于nodeport暴露的端口是随机端口，一般会在前面再搭建一套负载均衡器来转发请求。该方式一般用于宿主机是相对固定的环境ip地址不变的场景。<br>NodePort方式暴露ingress虽然简单方便，但是NodePort多了一层NAT，在请求量级很大时可能对性能会有一定影响。</p>
<h2 id="DaemonSet-HostNetwork-nodeSelector"><a href="#DaemonSet-HostNetwork-nodeSelector" class="headerlink" title="DaemonSet+HostNetwork+nodeSelector"></a>DaemonSet+HostNetwork+nodeSelector</h2><p>用DaemonSet结合nodeselector来部署ingress-controller到特定的node上，然后使用HostNetwork直接把该pod与宿主机node的网络打通，直接使用宿主机的80/433端口就能访问服务。这时，ingress-controller所在的node机器就很类似传统架构的边缘节点，比如机房入口的nginx服务器。该方式整个请求链路最简单，性能相对NodePort模式更好。缺点是由于直接利用宿主机节点的网络和端口，一个node只能部署一个ingress-controller pod。比较适合大并发的生产环境使用。</p>
<h1 id="七层代理实验"><a href="#七层代理实验" class="headerlink" title="七层代理实验"></a>七层代理实验</h1><h2 id="以DaemonSet-HostNetwork-方式实验"><a href="#以DaemonSet-HostNetwork-方式实验" class="headerlink" title="以DaemonSet+HostNetwork 方式实验"></a>以DaemonSet+HostNetwork 方式实验</h2><ol>
<li>配置ingress-controller<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">nginx-ingress-controller的kind</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> <span class="string">在serviceAccountName后方</span></span><br><span class="line"><span class="attr">serviceAccountName:</span> <span class="string">nginx-ingress-serviceaccount</span></span><br><span class="line"><span class="attr">hostNetwork:</span> <span class="literal">true</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>配置并启动一个deployment<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubia-cluster</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">luksa/kubia:v2</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li>
<li>配置并启动一个service<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubia-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">    <span class="attr">selector:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">kubia</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">ClusterIP</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">http</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="string">~</span>                        </span><br></pre></td></tr></table></figure></li>
<li>配置并启动一个ingress<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ingress-kubia</span></span><br><span class="line">  <span class="attr">annotations:</span></span><br><span class="line">    <span class="attr">kubernets.io/ingress.class:</span> <span class="string">&quot;nginx&quot;</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">rules:</span></span><br><span class="line">   <span class="bullet">-</span> <span class="attr">host:</span> <span class="string">k8s.oosm.com</span></span><br><span class="line">     <span class="attr">http:</span></span><br><span class="line">      <span class="attr">paths:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">pathType:</span> <span class="string">Prefix</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/kubia</span></span><br><span class="line">        <span class="attr">backend:</span></span><br><span class="line">          <span class="attr">service:</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">kubia-service</span></span><br><span class="line">            <span class="attr">port:</span></span><br><span class="line">              <span class="attr">number:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></li>
<li>访问<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 如果域名可以解析</span><br><span class="line">curl k8s.oosm.com&#x2F;kubia</span><br><span class="line">&#x2F;&#x2F; 如果域名不能解析</span><br><span class="line">curl -H &quot;Host:k8s.oosm.com&quot; target-ip&#x2F;kubia</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="四层代理实验"><a href="#四层代理实验" class="headerlink" title="四层代理实验"></a>四层代理实验</h1><ol>
<li>复用上面启动的deployment和service，不需要配置ingress</li>
<li>修改tcp的configMap<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># kubectl get cm -n ingress-nginx</span></span><br><span class="line"><span class="comment"># kubectl edit cm tcp-services -n ingress-nginx</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">&quot;4414&quot;:</span> <span class="string">default/kubia-service:8080</span></span><br></pre></td></tr></table></figure></li>
<li>调用<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; target-ip为该主机的ip</span><br><span class="line">curl target-ip&#x2F;4414    </span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>ingress</tag>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>k8s 部署记录</title>
    <url>/2021/02/25/k8s-deploy/</url>
    <content><![CDATA[<h1 id="k8s-部署"><a href="#k8s-部署" class="headerlink" title="k8s 部署"></a>k8s 部署</h1><ol>
<li>系统配置 （master和node节点均执行）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) 服务器开启硬件虚拟化支持</span><br><span class="line">2) 操作系统版本大于CentOS7.5</span><br><span class="line">3) 关闭SElinux和Firewalld服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl stop firewalld.service    </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sed -i <span class="string">&#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27;</span> /etc/sysconfig/selinux</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> setenforce 0</span></span><br><span class="line">4) 设置hostname并在/etc/hosts配置本地解析；</span><br><span class="line"><span class="meta">#</span><span class="bash"> hostnamectl set-hostname master</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vi /etc/hosts （添加配置所有节点的hostname和ip）</span></span><br><span class="line">5) 关闭Swap服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> swapoff -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> vm.swappiness=0 &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">6) 修改sysctl.conf （如果 cat /etc/sysctl.conf 已存在以下值，则可以直接修改）</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> modprobe br_netfilter</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sysctl -p</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> service network restart</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ol>
<a id="more"></a>
<ol start="2">
<li>安装docker （master和node节点均执行）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) 如果已安装过旧版本需要删除</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y remove docker-client docker-client-latest docker-common docker-latest docker-logrotate docker-latest-logrotate \ docker-selinux docker-engine-selinux docker-engine</span></span><br><span class="line"></span><br><span class="line">2) 设置阿里云docker仓库，并安装Docker服务</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install yum-utils lvm2 device-mapper-persistent-data nfs-utils xfsprogs wget</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install docker-ce docker-ce-cli containerd.io</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start docker</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="3">
<li>安装K8S服务 （master和node节点均执行）<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) 如果已安装过旧版本，需要删除：</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y remove kubelet kubadm kubctl</span></span><br><span class="line"></span><br><span class="line">2) 设置阿里云的仓库,并安装新版本</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat &gt; /etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span></span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">3）安装kubelet kubeadm kubectl</span><br><span class="line"><span class="meta">#</span><span class="bash"> yum -y install kubelet kubeadm kubectl --disableexcludes=kubernetes</span></span><br><span class="line"></span><br><span class="line">4) 修改Docker Cgroup Driver为systemd，如果不修改则在后续添加Worker节点时可能会遇到“detected cgroupfs as ths Docker driver.xx”的报错信息，并配置Docker本地镜像库；</span><br><span class="line"><span class="meta">#</span><span class="bash"> cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">    &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">    &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;storage-driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">    &quot;registry-mirrors&quot;:[</span><br><span class="line">        &quot;https://kfwkfulq.mirror.aliyuncs.com&quot;,</span><br><span class="line">        &quot;https://2lqq34jg.mirror.aliyuncs.com&quot;,</span><br><span class="line">        &quot;https://pee6w651.mirror.aliyuncs.com&quot;,</span><br><span class="line">        &quot;http://hub-mirror.c.163.com&quot;,</span><br><span class="line">        &quot;https://docker.mirrors.ustc.edu.cn&quot;,</span><br><span class="line">        &quot;https://registry.docker-cn.com&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">5) 重启Docker，并启动Kubelet</span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl daemon-reload</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl restart docker</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl <span class="built_in">enable</span> kubelet</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> systemctl start kubelet</span></span><br></pre></td></tr></table></figure>


</li>
</ol>
<ol start="4">
<li>配置master节点<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) 配置环境变量：</span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="built_in">export</span> MASTER_IP=10.0.0.11 &gt; k8s.env.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="built_in">export</span> APISERVER_NAME=master &gt;&gt; k8s.env.sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sh k8s.env.sh</span></span><br><span class="line">2) Master节点初始化：</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubeadm init \</span></span><br><span class="line">        --apiserver-advertise-address 0.0.0.0 \</span><br><span class="line">        --apiserver-bind-port 6443 \</span><br><span class="line">        --cert-dir /etc/kubernetes/pki \</span><br><span class="line">        --control-plane-endpoint master \</span><br><span class="line">        --image-repository registry.cn-hangzhou.aliyuncs.com/google_containers \</span><br><span class="line">        --kubernetes-version 1.20.4 \</span><br><span class="line">        --pod-network-cidr 10.11.0.0/16 \</span><br><span class="line">        --service-cidr 10.20.0.0/16 \</span><br><span class="line">        --service-dns-domain cluster.local \</span><br><span class="line">        --upload-certs </span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>参数说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--apiserver-advertise-address 0.0.0.0 \</span><br><span class="line"># API 服务器所公布的其正在监听的 IP 地址,指定“0.0.0.0”以使用默认网络接口的地址</span><br><span class="line"># 切记只可以是内网IP，不能是外网IP，如果有多网卡，可以使用此选项指定某个网卡</span><br><span class="line">--apiserver-bind-port 6443 \</span><br><span class="line"># API 服务器绑定的端口,默认 6443</span><br><span class="line">--cert-dir &#x2F;etc&#x2F;kubernetes&#x2F;pki \</span><br><span class="line"># 保存和存储证书的路径，默认值：&quot;&#x2F;etc&#x2F;kubernetes&#x2F;pki&quot;</span><br><span class="line">--control-plane-endpoint kuber4s.api \</span><br><span class="line"># 为控制平面指定一个稳定的 IP 地址或 DNS 名称,</span><br><span class="line"># 这里指定的 kuber4s.api 已经在 &#x2F;etc&#x2F;hosts 配置解析为本机IP</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com&#x2F;google_containers \</span><br><span class="line"># 选择用于拉取Control-plane的镜像的容器仓库，默认值：&quot;k8s.gcr.io&quot;</span><br><span class="line"># 因 Google被墙，这里选择国内仓库</span><br><span class="line">--kubernetes-version 1.17.3 \</span><br><span class="line"># 为Control-plane选择一个特定的 Kubernetes 版本， 默认值：&quot;stable-1&quot;</span><br><span class="line">--node-name master01 \</span><br><span class="line">#  指定节点的名称,不指定的话为主机hostname，默认可以不指定</span><br><span class="line">--pod-network-cidr 10.10.0.0&#x2F;16 \</span><br><span class="line"># 指定pod的IP地址范围</span><br><span class="line">--service-cidr 10.20.0.0&#x2F;16 \</span><br><span class="line"># 指定Service的VIP地址范围</span><br><span class="line">--service-dns-domain cluster.local \</span><br><span class="line"># 为Service另外指定域名，默认&quot;cluster.local&quot;</span><br><span class="line">--upload-certs</span><br><span class="line"># 将 Control-plane 证书上传到 kubeadm-certs Secret</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>master init后续操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 根据init后的输出内容提示执行命令即可</span><br><span class="line">mkdir -p $HOME&#x2F;.kube</span><br><span class="line">sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config</span><br></pre></td></tr></table></figure>
</li>
<li><p>node 节点安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1. 执行之前的前3步（注意hostname和hosts文件区分）</span><br><span class="line">2. 添加master的环境变量</span><br><span class="line"><span class="meta">#</span><span class="bash"> scp master:/root/k8s.env.sh .</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> sh k8s.env.sh</span></span><br><span class="line">2. 执行（来自于master 安装成功后的输出内容） </span><br><span class="line"><span class="meta">#</span><span class="bash">  kubeadm join master:6443 --token 7msc5c.bd6nelghcc7ik3g2 \</span></span><br><span class="line">    --discovery-token-ca-cert-hash sha256:99eda6366dc9c1b13282bca34cf359ab4cd2c3454530ca9f0f773dde62c4fc3c </span><br></pre></td></tr></table></figure>
</li>
<li><p>网络配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">在master节点上安装flannel:（试过有问题 不用）</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span></span><br><span class="line">或者安装 calico （flannel中存在问题  pod无法访问其他node 暂时没有解决）</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply -f https://docs.projectcalico.org/manifests/calico.yaml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检查</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//显示master和node全都Ready 即安装成功</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get nodes  </span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存在问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1) node节点执行kubectl： The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br><span class="line">// 把master节点的配置文件copy到node节点</span><br><span class="line"><span class="meta">#</span><span class="bash"> scp -r /etc/kubernetes/admin.conf <span class="variable">$&#123;node1&#125;</span>:/etc/kubernetes/admin.conf</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">echo</span> <span class="built_in">export</span> KUBECONFIG=/etc/kubernetes/admin.conf &gt;&gt; ~/.bash_profile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2) 在搭建k8s集群并整合flannel时，即使关闭了防火墙跨主机间容器、pod始终无法ping通 （目前不用flannel 作废）</span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -P INPUT ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -P FORWARD ACCEPT</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -F</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> iptables -L -n</span></span><br><span class="line"></span><br><span class="line">3) 搭建ingress-nginx</span><br><span class="line">kubectl apply -f mandatory.yaml </span><br><span class="line">// 存在nodeport和hostnetwork两种模式 采用的是hostnetwork模式</span><br></pre></td></tr></table></figure>
</li>
<li><p>搭建本地镜像仓库 </p>
</li>
</ol>
<ul>
<li><p>安装registry</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -p 5001:5000 -v &#x2F;opt&#x2F;data&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry -v &#x2F;opt&#x2F;data&#x2F;registry&#x2F;srv-config.yml:&#x2F;etc&#x2F;docker&#x2F;registry&#x2F;config.yml --privileged&#x3D;true --restart&#x3D;always docker.io&#x2F;registry </span><br></pre></td></tr></table></figure>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="number">0.1</span></span><br><span class="line"><span class="attr">log:</span></span><br><span class="line">  <span class="attr">fields:</span></span><br><span class="line">    <span class="attr">service:</span> <span class="string">registry</span></span><br><span class="line"><span class="attr">storage:</span></span><br><span class="line">  <span class="attr">delete:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">cache:</span></span><br><span class="line">    <span class="attr">blobdescriptor:</span> <span class="string">inmemory</span></span><br><span class="line">  <span class="attr">filesystem:</span></span><br><span class="line">    <span class="attr">rootdirectory:</span> <span class="string">/var/lib/registry</span></span><br><span class="line"><span class="attr">http:</span></span><br><span class="line">  <span class="attr">addr:</span> <span class="string">:5000</span></span><br><span class="line">  <span class="attr">headers:</span></span><br><span class="line">    <span class="attr">X-Content-Type-Options:</span> [<span class="string">nosniff</span>]</span><br><span class="line"><span class="attr">health:</span></span><br><span class="line">  <span class="attr">storagedriver:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">interval:</span> <span class="string">10s</span></span><br><span class="line">    <span class="attr">threshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>安装registry ui</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker pull hyper&#x2F;docker-registry-web</span><br><span class="line">docker run -d --name registry-web --restart&#x3D;always -p 8000:8080 -v &#x2F;opt&#x2F;data&#x2F;registry&#x2F;web-config.yml:&#x2F;conf&#x2F;config.yml hyper&#x2F;docker-registry-web</span><br><span class="line">&#x2F;&#x2F;  http:&#x2F;&#x2F;121.5.158.16:8000&#x2F;  ui地址</span><br></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">registry:</span></span><br><span class="line">  <span class="comment"># Docker registry url</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">http://x.x.x.x:5001/v2</span></span><br><span class="line">  <span class="comment"># Docker registry fqdn</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">localhost:5001</span></span><br><span class="line">  <span class="comment"># To allow image delete, should be false</span></span><br><span class="line">  <span class="attr">readonly:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">auth:</span></span><br><span class="line">    <span class="comment"># Disable authentication</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决“Http: server gave HTTP response to HTTPS client”<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 /etc/docker/daemon.json 中添加 (在push的那台主机上添加)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;insecure-registries&quot;</span>: [<span class="string">&quot;x.x.x.x:5001&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="11">
<li><p>安装metrics-server 支持HPA</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 修改yml</span><br><span class="line">   - --kubelet-insecure-tls</span><br><span class="line">   - --kubelet-preferred-address-types&#x3D;InternalIP</span><br><span class="line"></span><br><span class="line">2. 配置新镜像地址 （暂时找了个最新可用的）</span><br><span class="line">   docker pull bitnami&#x2F;metrics-server:0.4.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果获取不到镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 腾讯云申请一台按时付费的硅谷服务器</span><br><span class="line">2. 登陆</span><br><span class="line"># yum install docker</span><br><span class="line">&#x2F;&#x2F; 在 &#x2F;etc&#x2F;docker&#x2F;daemon.json 中添加 (在push的那台主机上添加 本地registry地址)</span><br><span class="line">&#123;</span><br><span class="line">    &quot;insecure-registries&quot;: [&quot;x.x.x.x:5000&quot;]  </span><br><span class="line">&#125;</span><br><span class="line"># systemctl daemon-reload</span><br><span class="line"># systemctl enable docker</span><br><span class="line"># systemctl start docker</span><br><span class="line">3. 保存以下脚本 docker.sh</span><br><span class="line">docker pull $1</span><br><span class="line">new&#x3D;$&#123;1&#x2F;gcr.io&#x2F;x.x.x.x:5001&#125;</span><br><span class="line">docker tag  $1 $new</span><br><span class="line">docker push $new</span><br><span class="line">echo $new</span><br><span class="line">4. 执行脚本</span><br><span class="line"># sh dcoker.sh 目标镜像</span><br><span class="line"></span><br><span class="line">5. 在镜像库ui上查询 http:&#x2F;&#x2F;x.x.x.x:8000&#x2F;</span><br></pre></td></tr></table></figure>
</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
      </categories>
      <tags>
        <tag>k8s</tag>
      </tags>
  </entry>
  <entry>
    <title>serverless 学习</title>
    <url>/2020/12/23/serverless/</url>
    <content><![CDATA[<ol>
<li>不用关心服务器</li>
<li>自动弹性</li>
<li>按实际使用计费</li>
<li>更少的代码，更快的交付速度</li>
</ol>
]]></content>
      <categories>
        <category>serverless</category>
      </categories>
      <tags>
        <tag>serverless k8s 云原生</tag>
      </tags>
  </entry>
  <entry>
    <title>spring 循环依赖问题</title>
    <url>/2020/10/15/spring-circle-ref/</url>
    <content><![CDATA[<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>循环依赖其实就是循环引用，也就是两个或则两个以上的bean互相持有对方，最终形成闭环。比如A依赖于B，B依赖于C，C又依赖于A。<br>spring 中的循环依赖场景有:</p>
<ol>
<li>构造器产生循环依赖</li>
<li>属性产生循环依赖<a id="more"></a>
<h1 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h1><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2>Spring中很好的解决了属性的循环依赖问题，所以通过以下的配置都不会报错</li>
<li>通过注解<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> B <span class="title">getB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setB</span><span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> A <span class="title">getA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setA</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>通过property 互相依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;A&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.A&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;B&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;B&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.B&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;A&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>通过autowired 配置相互依赖<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;A&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.A&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;B&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.B&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>首先回顾下 Bean加载的过程</p>
<ol>
<li>实例化Bean(createBeanInstance)： 实例化bean对象</li>
<li>注入属性(pupulateBean): 将依赖的属性进行填充</li>
<li>Bean初始化(InitializeBean): 执行配置的init方法或者自定义processor<br>循环依赖主要发生在第一步和第二步,bean解循环依赖的一个关键方法，众所周知的如下:<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">            singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">            <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">                ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = singletonFactory.getObject();</span><br><span class="line">                    <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                    <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
解释下其中的关键三个数据结构:</li>
</ol>
<ul>
<li>singletonObjects: 用于保存BeanName和创建bean实例之间的关系</li>
<li>earlySingletonObjects: 保存还在创建过程中的BeanName和bean实例的关系</li>
<li>singletonFactories: 用于保存BeanName和创建bean工厂之间的关系</li>
</ul>
<p>还是以上文中的A和B对象的初始化过程为例(第二种配置方式)</p>
<ul>
<li>进入refresh</li>
<li>对A进行getBean操作</li>
<li>创建A对象实例完成</li>
<li>添加构造A的ObjectFactory<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">//AbstractAutowireCapableBeanFactory中addSingletonFactory</span></span><br><span class="line"><span class="keyword">this</span>.singletonFactories.put(beanName, singletonFactory);</span><br></pre></td></tr></table></figure></li>
<li>A会进入beforeSingletonCreation方法，标识自己正在创建中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultSingletonBeanRegistry中beforeSingletonCreation</span></span><br><span class="line">singletonsCurrentlyInCreation.add(beanName) </span><br></pre></td></tr></table></figure></li>
<li>开始对A进行populateBean操作，开始注入依赖B</li>
<li>开始对B进行getBean操作</li>
<li>创建B对象实例</li>
<li>添加构造B的ObjectFactory(代码同上)</li>
<li>B会进入beforeSingletonCreation方法，标识自己正在创建中（代码同上）</li>
<li>开始对B进行populateBean操作，开始注入依赖A</li>
<li>B进入getSingleton寻找A<ul>
<li>因为A已经在创建中，所以进入到后续逻辑</li>
<li>在singletonObjects中没有找到A</li>
<li>在earlySingletonObjects中也没有找到A</li>
<li>在singletonFactories中找到factory并创建出A</li>
<li>将A添加到earlySingletonObjects中</li>
<li>B依赖该A对象完成</li>
</ul>
</li>
<li>B依赖完成后，将自己添加到singletonObjects中<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在DefaultSingletonBeanRegistry中addSingleton</span></span><br><span class="line"><span class="keyword">this</span>.singletonObjects.put(beanName, singletonObject);</span><br></pre></td></tr></table></figure></li>
<li>之后A对象会从getSingleton再获取一次，这次可以从early获取到自己<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">    Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之后A完成依赖注入，将自己也添加到singletonObjects中</li>
<li>此时A和B都已存在于singletonObjects中，以后的每次都会从中获取bean</li>
</ul>
<h1 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h1><h2 id="现象"><a href="#现象" class="headerlink" title="现象"></a>现象</h2><p>在默认情况下，spring并没有解决构造器方式的依赖注入，但是有一种配置方式可以解决<br>首先是存在问题的使用方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">(A a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 报错信息</span></span><br><span class="line"> Error creating bean with name <span class="string">&#x27;a&#x27;</span>: Requested bean is currently </span><br><span class="line"> in creation: Is there an unresolvable circular reference?</span><br></pre></td></tr></table></figure>

<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="comment">// 在构造器中给b添加上 @Lazy标签</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span> <span class="params">(<span class="meta">@Lazy</span> B b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><ol>
<li>在对A 进行createBean时，会执行构造方法相关逻辑<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractAutowireCapableBeanFactory#createBeanInstance中</span></span><br><span class="line">Constructor&lt;?&gt;[] ctors = determineConstructorsFromBeanPostProcessors(beanClass, beanName);</span><br><span class="line"><span class="keyword">if</span> (ctors != <span class="keyword">null</span> || mbd.getResolvedAutowireMode() == AUTOWIRE_CONSTRUCTOR ||</span><br><span class="line">		mbd.hasConstructorArgumentValues() || !ObjectUtils.isEmpty(args)) &#123;</span><br><span class="line">	<span class="keyword">return</span> autowireConstructor(beanName, mbd, ctors, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之后会执行构造方法参数的解析过程<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ConstructorResolver</span></span><br><span class="line"><span class="comment">// 执行createArgumentArray-&gt;resolveAutowiredArgument-&gt;resolveDependency</span></span><br><span class="line">Object result = getAutowireCandidateResolver().getLazyResolutionProxyIfNecessary(</span><br><span class="line">					descriptor, requestingBeanName);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后续对lazy的字段进行处理</span></span><br><span class="line"><span class="comment">// ContextAnnotationAutowireCandidateResolver</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getLazyResolutionProxyIfNecessary</span><span class="params">(DependencyDescriptor descriptor, <span class="meta">@Nullable</span> String beanName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断lazy注记后执行后续逻辑buildLazyResolutionProxy</span></span><br><span class="line">    <span class="keyword">return</span> (isLazy(descriptor) ? buildLazyResolutionProxy(descriptor, beanName) : <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个代理对象 </span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">buildLazyResolutionProxy</span><span class="params">(<span class="keyword">final</span> DependencyDescriptor descriptor, <span class="keyword">final</span> <span class="meta">@Nullable</span> String beanName)</span> </span>&#123;</span><br><span class="line">    Assert.state(getBeanFactory() <span class="keyword">instanceof</span> DefaultListableBeanFactory,</span><br><span class="line">            <span class="string">&quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;</span>);</span><br><span class="line">    <span class="keyword">final</span> DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) getBeanFactory();</span><br><span class="line">    TargetSource ts = <span class="keyword">new</span> TargetSource() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;</span><br><span class="line">            <span class="keyword">return</span> descriptor.getDependencyType();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">// getTarget中可以从beanFactory中取到真实的对象B</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">getTarget</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Object target = beanFactory.doResolveDependency(descriptor, beanName, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (target == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Class&lt;?&gt; type = getTargetClass();</span><br><span class="line">                <span class="keyword">if</span> (Map.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (List.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (Set.class == type || Collection.class == type) &#123;</span><br><span class="line">                    <span class="keyword">return</span> Collections.emptySet();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),</span><br><span class="line">                        <span class="string">&quot;Optional dependency not present for lazy injection point&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> target;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseTarget</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 生产代理对象</span></span><br><span class="line">    ProxyFactory pf = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">    pf.setTargetSource(ts);</span><br><span class="line">    Class&lt;?&gt; dependencyType = descriptor.getDependencyType();</span><br><span class="line">    <span class="keyword">if</span> (dependencyType.isInterface()) &#123;</span><br><span class="line">        pf.addInterface(dependencyType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pf.getProxy(beanFactory.getBeanClassLoader());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>TargetSource[目标源]，在Spring AOP体系中占有非常重要的地位，它是被代理对象的抽象表示，可以包含真实的被代理对象本身[直接包含]，也可以包含”能够获取被代理对象的代码”[间接包含]，因此称为目标”源”而非目标，隐喻着可以通过某种手段获取被代理对象，且多次获取的被代理对象可能是同一个，也可能不是同一个，这对于上层应用而言是无感知的，由TargetSource行为所决定.</p>
</blockquote>
</li>
</ol>
<p>通过在构造器参数中标识@Lazy注解，Spring 生成并返回了一个代理对象，因此给Foo注入的Bar并非真实对象而是其代理</p>
<ol start="3">
<li>如何去获取真实的B<br>在获取B的属性时，会进入Proxy<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 由于B不是接口，所以不能用jdk的proxy 使用的是cglib的代理 CglibAopProxy</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">   <span class="comment">//...</span></span><br><span class="line">   <span class="comment">// Get as late as possible to minimize the time we &quot;own&quot; the target, in case it comes from a pool...</span></span><br><span class="line">    target = targetSource.getTarget();</span><br><span class="line">    Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);</span><br><span class="line">    <span class="comment">//通过反射执行被代理对象的方法，获取相对应的属性</span></span><br><span class="line">    retVal = methodProxy.invoke(target, argsToUse);</span><br><span class="line">    retVal = processReturnType(proxy, target, method, retVal);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>代理对象Bar与真实的Bar对象，是通过TargetSouce关联起来的，每次执行被代理对象的方法时，都会先通过TargetSouce去拿到真实的对象[DefaultListableBeanFactory#doResolveDependency]，然后通过反射进行调用</p>
</blockquote>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>Spring构造器注入循环依赖的解决方案是@Lazy，其基本思路是：对于强依赖的对象，一开始并不注入对象本身，而是注入其代理对象，以便顺利完成实例的构造，形成一个完成的对象，这样与其它应用层对象就不会形成互相依赖的关系；当需要调用真实对象的方法时，通过TargetSouce去拿到真实的对象[DefaultListableBeanFactory#doResolveDependency]，然后通过反射完成调用</p>
<h2 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h2><p>prototype类型没有解决循环依赖<br>以下的代码是会报错的</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;A&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.A&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;B&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;B&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.B&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;A&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>以下的配置时没有问题的!!!</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;A&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.A&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;b&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;B&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;B&quot;</span> <span class="attr">class</span>=<span class="string">&quot;circle.B&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;a&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;A&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>spring 自定义标签</title>
    <url>/2020/10/14/spring-nameSpaceHandler/</url>
    <content><![CDATA[<h1 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h1><p>Spring 提供了可扩展Schema的支持，扩展Spring自定义标签配置大致需要以下几个步骤</p>
<ul>
<li>创建一个需要扩展的组件</li>
<li>定义一个XSD文件描述组件内容</li>
<li>创建一个文件，实现BeanDefinitionParser接口，用来解析XSD文件中的定义和组件定义</li>
<li>创建一个Handler文件，扩展自NamespaceHandlerSupport,目的是将组件注册到Spring容器</li>
<li>在META-INF下编写Spring.handlers 和 Spring.schemas 文件<a id="more"></a>
以一个例子说明：</li>
</ul>
<ol>
<li><p>创建一个普通的pojo</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getEmail</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> email;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmail</span><span class="params">(String email)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>定义一个XSD文件 (命名为user.xsd 放置在META-INF中)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;no&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">xsd:schema</span></span></span><br><span class="line"><span class="tag">        <span class="attr">xmlns:xsd</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">targetNamespace</span>=<span class="string">&quot;http://www.unionpay.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">elementFormDefault</span>=<span class="string">&quot;qualified&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xsd:element</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xsd:attribute</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">type</span>=<span class="string">&quot;xsd:string&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xsd:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xsd:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xsd:schema</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>编写spring.handlers,spring.schemas文件 (放置在META-INF中）</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">//spring.handlers</span></span><br><span class="line"><span class="meta">http\://www.unionpay.com/schema/user</span>=<span class="string">schema.MyNamespaceHanlder</span></span><br><span class="line"></span><br><span class="line"><span class="attr">//spring.schemas</span></span><br><span class="line"><span class="meta">http\://www.unionpay.com/schema/user.xsd</span>=<span class="string">META-INF/user.xsd</span></span><br></pre></td></tr></table></figure></li>
<li><p>创建一个自定义标签的解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanDefinitionParser</span> <span class="keyword">extends</span> <span class="title">AbstractSingleBeanDefinitionParser</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; getBeanClass(Element element) &#123;</span><br><span class="line">        <span class="keyword">return</span> User.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doParse</span><span class="params">(Element element, BeanDefinitionBuilder builder)</span> </span>&#123;</span><br><span class="line">        String email = element.getAttribute(<span class="string">&quot;email&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasText(email)) &#123;</span><br><span class="line">            builder.addPropertyValue(<span class="string">&quot;email&quot;</span>, email);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>创建MyNamespaceHanlder </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNamespaceHanlder</span> <span class="keyword">extends</span> <span class="title">NamespaceHandlerSupport</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        registerBeanDefinitionParser(<span class="string">&quot;user&quot;</span>,<span class="keyword">new</span> UserBeanDefinitionParser());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建xml，创建测试类</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:myname</span>=<span class="string">&quot;http://www.unionpay.com/schema/user&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.unionpay.com/schema/user http://www.unionpay.com/schema/user.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       &quot;</span> <span class="attr">default-lazy-init</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">myname:user</span> <span class="attr">id</span>=<span class="string">&quot;user1&quot;</span> <span class="attr">email</span>=<span class="string">&quot;test&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;app2.xml&quot;</span>);</span><br><span class="line">        User user = applicationContext.getBean(User.class);</span><br><span class="line">        System.out.println(user.getEmail());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="源码学习"><a href="#源码学习" class="headerlink" title="源码学习"></a>源码学习</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">parseBeanDefinitions</span><span class="params">(Element root, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">        NodeList nl = root.getChildNodes();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">            Node node = nl.item(i);</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">                Element ele = (Element) node;</span><br><span class="line">                <span class="keyword">if</span> (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">                    parseDefaultElement(ele, delegate);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    delegate.parseCustomElement(ele);  <span class="comment">// 解析自定义的元素</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        delegate.parseCustomElement(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据ele获取namespace的uri</span></span><br><span class="line">    String namespaceUri = getNamespaceURI(ele);</span><br><span class="line">    <span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据namespace的uri 获取用户的handler</span></span><br><span class="line">    NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line">    <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(<span class="string">&quot;Unable to locate Spring NamespaceHandler for XML schema namespace [&quot;</span> + namespaceUri + <span class="string">&quot;]&quot;</span>, ele);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的解析</span></span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> BeanDefinition <span class="title">parse</span><span class="params">(Element element, ParserContext parserContext)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// parseInternal 会一直进入到用户自定义的beanDefinitionParser</span></span><br><span class="line">    AbstractBeanDefinition definition = parseInternal(element, parserContext);</span><br><span class="line">    <span class="keyword">if</span> (definition != <span class="keyword">null</span> &amp;&amp; !parserContext.isNested()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String id = resolveId(element, definition, parserContext);</span><br><span class="line">            <span class="keyword">if</span> (!StringUtils.hasText(id)) &#123;</span><br><span class="line">                parserContext.getReaderContext().error(</span><br><span class="line">                        <span class="string">&quot;Id is required for element &#x27;&quot;</span> + parserContext.getDelegate().getLocalName(element)</span><br><span class="line">                                + <span class="string">&quot;&#x27; when used as a top-level tag&quot;</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">            String[] aliases = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (shouldParseNameAsAliases()) &#123;</span><br><span class="line">                String name = element.getAttribute(NAME_ATTRIBUTE);</span><br><span class="line">                <span class="keyword">if</span> (StringUtils.hasLength(name)) &#123;</span><br><span class="line">                    aliases = StringUtils.trimArrayElements(StringUtils.commaDelimitedListToStringArray(name));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            BeanDefinitionHolder holder = <span class="keyword">new</span> BeanDefinitionHolder(definition, id, aliases);</span><br><span class="line">            registerBeanDefinition(holder, parserContext.getRegistry());</span><br><span class="line">            <span class="keyword">if</span> (shouldFireEvents()) &#123;</span><br><span class="line">                BeanComponentDefinition componentDefinition = <span class="keyword">new</span> BeanComponentDefinition(holder);</span><br><span class="line">                postProcessComponentDefinition(componentDefinition);</span><br><span class="line">                parserContext.registerComponent(componentDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">            String msg = ex.getMessage();</span><br><span class="line">            parserContext.getReaderContext().error((msg != <span class="keyword">null</span> ? msg : ex.toString()), element);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> definition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title>consul 详解</title>
    <url>/2020/11/12/consul/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Consul 是一个支持多数据中心分布式高可用的服务发现和配置共享的服务软件,由 HashiCorp 公司用 Go 语言开发, 基于 MPL 2.0 的协议进行开源. </p>
<ul>
<li>service mesh solution providing a full featured control plane with service discovery, configuration, and segmentation functionality</li>
<li>requires a data plane and supports both a proxy and native integration model.</li>
<li>ships with a simple built-in proxy,supports 3rd party proxy integrations</li>
</ul>
<a id="more"></a>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>服务发现:<br>提供了通过DNS或者HTTP接口的方式来注册服务和发现服务。</li>
<li>健康检查:<br>Consul的Client可以提供任意数量的健康检查，既可以与给定的服务相关联(“webserver是否返回200 OK”)，也可以与本地节点相关联(“内存利用率是否低于90%”)。操作员可以使用这些信息来监视集群的健康状况，服务发现组件可以使用这些信息将流量从不健康的主机路由出去。</li>
<li>key/value 存储:<br>应用程序可以根据自己的需要使用Consul提供的Key/Value存储， Consul提供了简单易用的HTTP接口，结合其他工具可以实现动态配置、功能标记、领袖选举等等功能。</li>
<li>安全服务通信:<br>Consul可以为服务生成和分发TLS证书，以建立相互的TLS连接。</li>
<li>多数据中心:<br>Consul支持开箱即用的多数据中心. 这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域。</li>
</ol>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p><img src="/2020/11/12/consul/compare.png" alt="123"></p>
<h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ul>
<li>Server：运行Server模式的Agent，参与Raft quorum，维护集群的状态，响应RPC读写，与其他数据中心交互WAN gossip，转发查询到Leader或远程数据中心。</li>
<li>Client ：运行client模式的Agent，将所有的RPCs转发到Server。Client是相对无状态的。Client唯一所做的是在后台参与LAN gossip pool。只消耗少量的资源，少量的网络带宽。 </li>
<li>Datacenter：每个数据中心有自己独立的leader，数据中心之间不会进行选举和数据同步，只会对请求进行转发。</li>
<li>Consensus:  Consensus 来表明就 leader 选举和事务的顺序达成一致</li>
<li>LAN Gossip：指的是LAN gossip pool，包含位于同一个局域网或者数据中心的节点</li>
<li>WAN Gossip:指的是WAN gossip pool，只包含server节点，这些server主要分布在不同的数据中心或者通信是基于互联网或广域网的</li>
<li>RPC： 远程过程调用。是允许client请求服务器的请求/响应机制</li>
</ul>
<h3 id="启动端口说明"><a href="#启动端口说明" class="headerlink" title="启动端口说明"></a>启动端口说明</h3><ul>
<li>DNS: The DNS server (TCP and UDP)   8600</li>
<li>HTTP: The HTTP API (TCP Only)  8500</li>
<li>LAN Serf: The Serf LAN port (TCP and UDP)   8301</li>
<li>Wan Serf: The Serf WAN port (TCP and UDP)   8302</li>
<li>server: Server RPC address (TCP Only)  8300</li>
</ul>
<p><img src="/2020/11/12/consul/consul-arch.png" alt="123"></p>
<ul>
<li>采用clients和servers混部模式，server建议三到五台，client没有限制，可以轻松扩展到成千上万台。</li>
<li>gossip协议<ul>
<li>维护成员关系</li>
<li>了解集群中还有哪些成员和其健康状况</li>
</ul>
</li>
<li>每个数据中心的servers都是属于一个Raft peer<ul>
<li>leader 负责所有的查询和事务</li>
<li>事务通过Consensus协议负复制到所有的参与者</li>
<li>当一个非leader收到一个rpc请求，它会转发给leader</li>
</ul>
</li>
<li>lan gossip<ul>
<li>同一数据中心，所有节点</li>
<li>没有必要为client配置所有服务器地址参数,发现是自动完成的</li>
<li>健康检查故障的工作不是放在服务器上，而是分布在客户端的，这使故障检测比心跳机制更可扩展性；也支持节点自身的健康检查</li>
<li>可用来作为消息层通知重要的事件</li>
</ul>
</li>
<li>wan gossip<ul>
<li>跨数据中心，仅server</li>
<li>具有更高的延迟，包括了其他consul集群的server节点</li>
<li>数据中心能够彼此发现，将一个新的数据中心加入现有的WAN gossip也很容易</li>
<li>当一个server接收对于另一个不同集群的请求时，它发送到指定集群的随机的一台server上，然后该server会转发给leader</li>
<li>数据中心低耦合，但通过错误检测，链接缓存复用，跨数据中心的请求相对较快和可靠</li>
</ul>
</li>
<li>在某些场景，client agent 可以缓存数据<ul>
<li>对一些认证和链路进行缓存</li>
<li>某些api终端支持可选的结果缓存，部分的服务发现和链接授权可以在server暂时不可用时从client获取</li>
</ul>
</li>
<li>集群内数据的读写请求既可以直接发到Server，也可以通过Client使用RPC转发到Server，请求最终会到达Leader节点，在允许数据轻微陈旧的情况下，读请求也可以在普通的Server节点完成</li>
</ul>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p><img src="/2020/11/12/consul/use.jpeg" alt="app"></p>
<h1 id="功能详解"><a href="#功能详解" class="headerlink" title="功能详解"></a>功能详解</h1><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册</span><br><span class="line">curl  --request PUT  --data @&#x2F;Users&#x2F;miaoshui&#x2F;D&#x2F;data&#x2F;consul&#x2F;test.json http:&#x2F;&#x2F;localhost:8900&#x2F;v1&#x2F;agent&#x2F;service&#x2F;register</span><br><span class="line">&#x2F;&#x2F; 订阅</span><br><span class="line">curl  http:&#x2F;&#x2F;localhost:8900&#x2F;v1&#x2F;agent&#x2F;service&#x2F;test111 (serviceId 且唯一)</span><br><span class="line">curl  http:&#x2F;&#x2F;localhost:8903&#x2F;v1&#x2F;catalog&#x2F;service&#x2F;test （serviceName）</span><br><span class="line">&#x2F;&#x2F; 解除注册</span><br><span class="line">curl --request PUT http:&#x2F;&#x2F;127.0.0.1:8900&#x2F;v1&#x2F;agent&#x2F;service&#x2F;deregister&#x2F;test111</span><br></pre></td></tr></table></figure>
<h2 id="KV-存储"><a href="#KV-存储" class="headerlink" title="KV 存储"></a>KV 存储</h2><ul>
<li>支持键值对的读取</li>
<li>支持建立多级目录</li>
<li>base64-encoded blob</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">// 增，改</span><br><span class="line">curl --request PUT --data “12345” http://127.0.0.1:8900/v1/kv/test1</span><br><span class="line">// 查</span><br><span class="line">curl http://127.0.0.1:8900/v1/kv/test1</span><br><span class="line">// 支持多层级</span><br><span class="line">curl http://127.0.0.1:8900/v1/kv/city/town</span><br><span class="line">// 删除</span><br><span class="line">curl -X DELETE http://127.0.0.1:8900/v1/kv/test1</span><br></pre></td></tr></table></figure>

<h2 id="健康检查"><a href="#健康检查" class="headerlink" title="健康检查"></a>健康检查</h2><p>在注册服务时，指定consul回调的接口</p>
<ul>
<li>script+interval</li>
<li>http+interval</li>
<li>tcp+interval</li>
<li>time to live</li>
<li>docker+interval</li>
<li>grpc+interval</li>
<li>alias<blockquote>
<p>ref <a href="https://www.consul.io/docs/discovery/checks">https://www.consul.io/docs/discovery/checks</a></p>
</blockquote>
</li>
</ul>
<h2 id="ACL"><a href="#ACL" class="headerlink" title="ACL"></a>ACL</h2><p>基础组成<br><img src="/2020/11/12/consul/acl.png" alt="123"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 基础操作</span><br><span class="line">curl --header &quot;X-Consul-Token:dcb93655-0661-4ea1-bfc4-e5744317f99e&quot; http:&#x2F;&#x2F;127.0.0.1:8910&#x2F;v1&#x2F;agent&#x2F;members</span><br><span class="line">curl http:&#x2F;&#x2F;127.0.0.1:8910&#x2F;v1&#x2F;agent&#x2F;members</span><br></pre></td></tr></table></figure>
<ol>
<li>token<br>最终生成被用户使用，一个token可以被赋予多个roles或者多个policies</li>
<li>policies<br>具体的权限控制策略<br>demo:<figure class="highlight h"><table><tr><td class="code"><pre><span class="line">service <span class="string">&quot;magpie&quot;</span> &#123;</span><br><span class="line">	policy = <span class="string">&quot;write&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">service <span class="string">&quot;magpie-sidecar-proxy&quot;</span> &#123;</span><br><span class="line">	policy = <span class="string">&quot;write&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">service_prefix <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	policy = <span class="string">&quot;read&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">node_prefix <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">	policy = <span class="string">&quot;read&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li>roles<br>关联了多个policies的角色</li>
</ol>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p> Consul Agent支持对其所有的网络数据流进行加密，有两个独立的加密系统：Gossip Traffic和RPC</p>
<ul>
<li>Gossip Encryption<ul>
<li>启用Gossip加密方式，只需要在启动Agent时设置加密密钥</li>
<li>Key值必须是16字节，基于base64编码</li>
<li>consul keygen命令来生成满足要求的加密密钥</li>
<li>Consul集群中所有的节点必须使用相同的加密key——便于接收发送集群信息</li>
</ul>
</li>
<li>RPC Encryption with TLS<ul>
<li>Consul支持使用TLS校验server和client的授权</li>
<li>Consul要求所有的客户端和服务器都有由独立的证书颁发机构生成的密钥对</li>
<li>一个私有CA，只在内部使用。CA为每个代理签发密钥</li>
</ul>
</li>
</ul>
<h2 id="其他API功能点"><a href="#其他API功能点" class="headerlink" title="其他API功能点"></a>其他API功能点</h2><ol>
<li>watch 机制 (cli指令)<br>Watches是查看指定数据信息的一种方法，比如查看nodes列表、键值对、健康检查。当监控到更新时，可以调用外部处理程序——可以自定义。比如，发现健康状态发生变化可以通知外部系统健康异常。<br>支持如下类型：</li>
</ol>
<ul>
<li>Key – 监视指定K/V键值对</li>
<li>Keyprefix – Watch a prefix in the KV store</li>
<li>Services – 监视服务列表</li>
<li>nodes – 监控节点列表</li>
<li>service – 监视服务实例</li>
<li>checks- 监视健康检查的值</li>
<li>event – 监视用户事件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consul watch -typeservice -service redis &#x2F;usr&#x2F;bin&#x2F;my-service-handler.sh</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 可以在配置文件中配置触发path</span><br><span class="line">&#123;</span><br><span class="line">  &quot;watches&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;type&quot;: &quot;checks&quot;,</span><br><span class="line">      &quot;handler_type&quot;: &quot;http&quot;,</span><br><span class="line">      &quot;state&quot;: &quot;critical&quot;,</span><br><span class="line">      &quot;http_handler_config&quot;: &#123;</span><br><span class="line">        &quot;path&quot;: &quot;http:&#x2F;&#x2F;192.168.80.71:9000&#x2F;notice&quot;,</span><br><span class="line">        &quot;method&quot;: &quot;POST&quot;,</span><br><span class="line">        &quot;timeout&quot;: &quot;10s&quot;,</span><br><span class="line">        &quot;header&quot;: &#123; &quot;Authorization&quot;: [ &quot;token&quot; ] &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="2">
<li><p>event （api和cli）<br>可以通过api触发事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;consul watch -type&#x3D;event -name&#x3D;helloserviceevent &#x2F;Use&#x2F;cuixin&#x2F;ConsulStudy&#x2F;mac-dev&#x2F;echo_handler.sh -helloservice</span><br><span class="line"></span><br><span class="line">curl \</span><br><span class="line">    --request PUT \</span><br><span class="line">    --data @payload \</span><br><span class="line">    http:&#x2F;&#x2F;127.0.0.1:8500&#x2F;v1&#x2F;event&#x2F;fire&#x2F;helloserviceevent</span><br></pre></td></tr></table></figure>
</li>
<li><p>blocking query </p>
<ul>
<li>用来对一个可能发生变化的节点进行长轮询</li>
<li>通过设置 wait 参数，来设置长轮询的等待时间</li>
<li>最大十分钟，默认五分钟</li>
</ul>
</li>
<li><p>Consistency Modes</p>
<ul>
<li>default:  默认获取强一致性数据， 只有在新leader 选举过程中有可能获取到脏数据</li>
<li>consistent ： 确认一致性，需要leader和其他节点确认自己仍然是leader后再读取数据</li>
<li>steal： 允许从非leader节点上读取数据， 即使集群不可用也可以读取数据</li>
</ul>
</li>
<li><p>Filtering</p>
<ul>
<li>返回数据之前，将在Consul服务器上执行过滤，从而减少了网络负载<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -G &lt;path&gt; --data-urlencode &#39;filter&#x3D;&lt;filter expression&gt;&#39;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Agent Caching</p>
<ul>
<li>simple: 简单缓存</li>
<li>background refresh：后台刷新缓存 (background blocking query)</li>
</ul>
</li>
</ol>
<h2 id="Consul-工具"><a href="#Consul-工具" class="headerlink" title="Consul 工具"></a>Consul 工具</h2><h3 id="consul-templete"><a href="#consul-templete" class="headerlink" title="consul templete"></a>consul templete</h3><ol>
<li>概念</li>
</ol>
<ul>
<li>Consul-Template是基于Consul的自动替换配置文件的应用。</li>
<li>Consul-Template提供了一个便捷的方式从Consul中获取存储的值，Consul-Template守护进程会查询Consul实例来更新系统上指定的任何模板。当更新完成后，模板还可以选择运行一些任意的命令。</li>
<li><a href="https://github.com/hashicorp/consul-template">https://github.com/hashicorp/consul-template</a></li>
</ul>
<ol start="2">
<li>场景<br>Consul-Template可以查询Consul中的服务目录、Key、Key-values等。这种强大的抽象功能和查询语言模板可以使Consul-Template特别适合动态的创建配置文件。例如：创建Apache/Nginx Proxy Balancers、Haproxy Backends、Varnish Servers、Application Configurations等。</li>
<li>特点</li>
</ol>
<ul>
<li>Quiescence：Consul-Template内置静止平衡功能，可以智能的发现Consul实例中的更改信息。这个功能可以防止频繁的更新模板而引起系统的波动。</li>
<li>Dry Mode：不确定当前架构的状态，担心模板的变化会破坏子系统？无须担心。因为Consul-Template还有Dry模式。在Dry模式，Consul-Template会将结果呈现在STDOUT，所以操作员可以检查输出是否正常，以决定更换模板是否安全。</li>
<li>CLI and Config：Consul-Template同时支持命令行和配置文件。</li>
<li>Verbose Debugging：即使每件事你都做的近乎完美，但是有时候还是会有失败发生。Consul-Template可以提供更详细的Debug日志信息。<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3></li>
<li>Envconsul： 从consul中读取并设置环境变量给其他进程</li>
<li>Consul ESM ： 提供外部的服务监控</li>
<li>Consul Migrate : 数据迁移工具</li>
<li>Consul Replicate：跨中心的kv数据复制</li>
</ul>
<h1 id="操作演示"><a href="#操作演示" class="headerlink" title="操作演示"></a>操作演示</h1><ol>
<li><p>拉取镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull consul</span><br></pre></td></tr></table></figure></li>
<li><p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动第1个Server节点，集群要求要有3个Server，将容器8500端口映射到主机8900端口，同时开启管理界面</span></span><br><span class="line">docker run -d --name=consul1 -p 8900:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 -ui</span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动第2个Server节点，并加入集群</span></span><br><span class="line">docker run -d --name=consul2 -p 8901:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 --join 172.17.0.2</span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动第3个Server节点，并加入集群</span></span><br><span class="line">docker run -d --name=consul3 -p 8902:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 --join 172.17.0.2</span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动第4个Client节点，并加入集群</span></span><br><span class="line">docker run -d --name=consul4 -p 8903:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">false</span> --client=0.0.0.0 --join 172.17.0.2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以再创建一个中心</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动第1个Server节点，集群要求要有3个Server，将容器8500端口映射到主机8900端口，同时开启管理界面</span></span><br><span class="line">docker run -d --name=bj_consul1 -p 8910:8500 -v /Users/miaoshui/D/data/consul/consul_bj1/config:/consul/config -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=1 --client=0.0.0.0  -datacenter=dc2 -ui</span><br><span class="line"></span><br><span class="line">// 开启acl 放置在目录下 acl.hcl</span><br><span class="line">primary_datacenter = <span class="string">&quot;dc2&quot;</span></span><br><span class="line">acl &#123;</span><br><span class="line">  enabled = <span class="literal">true</span></span><br><span class="line">  default_policy = <span class="string">&quot;deny&quot;</span></span><br><span class="line">  enable_token_persistence = <span class="literal">true</span></span><br><span class="line">  tokens &#123;</span><br><span class="line">    master = <span class="string">&quot;dcb93655-0661-4ea1-bfc4-e5744317f99e&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">docker inspect -f <span class="string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> bj_consul1</span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动第2个Server节点，并加入集群</span></span><br><span class="line">docker run -d --name=bj_consul2 -p 8911:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 --join 172.17.0.6 -datacenter=dc2 </span><br><span class="line"> </span><br><span class="line"><span class="comment">#启动第3个Server节点，并加入集群</span></span><br><span class="line">docker run -d --name=bj_consul3 -p 8912:8500 -e CONSUL_BIND_INTERFACE=eth0 consul agent --server=<span class="literal">true</span> --bootstrap-expect=3 --client=0.0.0.0 --join 172.17.0.6 -datacenter=dc2 </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>关联</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker exec bj_consul1 consul join -wan 172.17.0.2</span><br></pre></td></tr></table></figure>
</li>
<li><p>可以进入容器查看</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it consul1 sh</span><br><span class="line">docker container update --restart=always  // 重启后 容器也启动</span><br></pre></td></tr></table></figure>
</li>
<li><p>api</p>
</li>
</ol>
<ul>
<li>java客户端使用方式<br>有 orbitz 与 ecwid，<br>ecwid是spring-cloud-consul-core的依赖包</li>
<li>注册发现和健康检查<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ConsulClient client = <span class="keyword">new</span> ConsulClient(<span class="string">&quot;localhost&quot;</span>, <span class="number">8900</span>);</span><br><span class="line"><span class="comment">// consul的格式化服务</span></span><br><span class="line">NewService service = <span class="keyword">new</span> NewService();</span><br><span class="line">service.setAddress(ip);</span><br><span class="line">service.setPort(port);</span><br><span class="line">service.setId(ip + <span class="string">&quot;:&quot;</span> + port);</span><br><span class="line">service.setName(<span class="string">&quot;magpie&quot;</span>);</span><br><span class="line"><span class="comment">// 健康检查</span></span><br><span class="line">NewService.Check check = <span class="keyword">new</span> NewService.Check();</span><br><span class="line">check.setHttp(<span class="string">&quot;http://192.168.0.106:8080/health&quot;</span>);</span><br><span class="line">check.setInterval(<span class="string">&quot;1000ms&quot;</span>);</span><br><span class="line">service.setCheck(check);</span><br><span class="line"><span class="comment">// 进行注册</span></span><br><span class="line">client.agentServiceRegister(service);</span><br><span class="line"><span class="comment">// 进行订阅 （需要自己订阅）</span></span><br><span class="line"> HealthServicesRequest request = HealthServicesRequest.newBuilder()</span><br><span class="line">                .setQueryParams(QueryParams.DEFAULT)</span><br><span class="line">                .setPassing(<span class="keyword">true</span>)</span><br><span class="line">                .build();</span><br><span class="line">Response&lt;List&lt;HealthService&gt;&gt;client.getHealthServices(service, request);</span><br><span class="line"><span class="comment">// 客户端主动检查（需要自己轮询）</span></span><br><span class="line">client.agentCheckPass(key, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></li>
<li>kv 数据存储<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] binaryData = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;;</span><br><span class="line">client.setKVBinaryValue(<span class="string">&quot;someKey&quot;</span>, binaryData);</span><br><span class="line"></span><br><span class="line">client.setKVValue(<span class="string">&quot;com.my.app.foo&quot;</span>, <span class="string">&quot;foo&quot;</span>);</span><br><span class="line"></span><br><span class="line">Response&lt;GetValue&gt; keyValueResponse = client.getKVValue(<span class="string">&quot;com.my.app.foo&quot;</span>);</span><br><span class="line">System.out.println(keyValueResponse.getValue().getKey() + <span class="string">&quot;: &quot;</span> + keyValueResponse.getValue().getDecodedValue()); <span class="comment">// prints &quot;com.my.app.foo: foo&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h1 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h1><h3 id="Gossip"><a href="#Gossip" class="headerlink" title="Gossip"></a>Gossip</h3><ul>
<li>概念: 是基于流行病传播方式的节点或者进程之间信息交换的协议,Gossip协议的主要用途就是信息传播和扩散。它们也被用于数据库复制，信息扩散，集群成员身份确认，故障探测等。基于Gossip协议的一些有名的系统：Apache Cassandra，Redis（Cluster模式），Consul等</li>
<li>分类<ul>
<li>LAN ： 包含一个数据中心内所有的client和server <ul>
<li>client可以自动发现服务，减少配置信息</li>
<li>分布式的错误检测，可以快速被集群共享</li>
<li>支持可靠快速的事件广播</li>
</ul>
</li>
<li>WAN<ul>
<li>所有集群的server都会加入</li>
<li>server 可以处理跨集群的请求</li>
<li>错误检测可以处理整个远程集群或者其中一台的链接丢失</li>
</ul>
</li>
</ul>
</li>
<li>算法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、Gossip 是周期性的散播消息，把周期限定为 1 秒</span><br><span class="line">2、被感染节点随机选择 k 个邻接节点（fan-out）散播消息（如果 fan-out 设置为 2，每次最多往 2 个节点散播）</span><br><span class="line">3、每次散播消息都选择尚未发送过的节点进行散播</span><br><span class="line">4、收到消息的节点不再往发送节点散播，比如 A -&gt; B，那么 B 进行散播的时候，不再发给 A。</span><br></pre></td></tr></table></figure>
<img src="/2020/11/12/consul/gossip.gif" alt="gossip1"></li>
<li>传播方式<ul>
<li>Anti-Entropy （以固定的概率传播所有的数据）：反熵传播过程是每个节点周期性地随机选择其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异<ul>
<li>Suspective:处于 susceptible 状态的节点代表其并没有收到来自其他节点的更新</li>
<li>Infective：处于 infective 状态的节点代表其有数据更新，并且会将这个数据分享给其他节点</li>
<li>缺点:每次节点两两交换自己的所有数据会带来非常大的通信负担</li>
</ul>
</li>
<li>Rumor-Mongering (以固定的概率仅传播新到达的数据): 谣言传播过程是消息只包含最新 update，谣言消息在某个时间点之后会被标记为removed，并且不再被传播<ul>
<li>Suspective</li>
<li>Infective </li>
<li>Removed:其已经接收到来自其他节点的更新，但是其并不会将这个更新分享给其他节点</li>
<li>缺点:系统有一定的概率会不一致，通常用于节点间数据增量同步</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h3><p><img src="/2020/11/12/consul/protocol.png" alt="protocol"></p>
<h4 id="算法解释"><a href="#算法解释" class="headerlink" title="算法解释"></a>算法解释</h4><ol>
<li><p>角色</p>
<ul>
<li>Leader 接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志。</li>
<li>Follower 接受并持久化Leader同步的日志，在Leader告之日志可以提交之后，提交日志。</li>
<li>Candidate Leader选举过程中的临时角色。</li>
</ul>
</li>
<li><p>角色状态转换<br><img src="/2020/11/12/consul/raft.jpg" alt="raft"></p>
</li>
<li><p>任期<br><img src="/2020/11/12/consul/term.png" alt="term"><br>Raft算法将时间分为一个个的任期（term），每一个term的开始都是Leader选举。在成功选举Leader之后，Leader会在整个term内管理整个集群。如果Leader选举失败，该term就会因为没有Leader而结束。</p>
</li>
</ol>
<p>参考动画：</p>
<ol>
<li><a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a></li>
<li><a href="https://raft.github.io/">https://raft.github.io/</a></li>
</ol>
<p>几个子问题：</p>
<ul>
<li>Leader Election</li>
<li>Log Replication</li>
<li>Safety</li>
</ul>
<ol>
<li>选举</li>
</ol>
<ul>
<li>服务器启动时，初始化为follower， leader向所有followers 周期性发送心跳，如果follow在选举超时时间内没有收到leader的心跳，则等待一段随机时间后发起一次leader选举。</li>
<li>follower 将其term加一然后转换为candidate； 首先给自己投票并且给集群的其他服务器发送RequestVoteRpc（最后一条日志记录的term_id和index）</li>
<li>规则<ul>
<li>Term<ul>
<li>候选人的 Term 必须大于投票者的 Term，否则就立马拒绝投票</li>
</ul>
</li>
<li>候选人最后一条日志<ul>
<li>候选人的最后一条日志的 Term 要大于投票者的最后一条日志的 Term（保证日志最新） 或者当它们的最后一条日志的 Term 相同时，候选人最后一条日志的 Index 要大于等于投票者（保证日志最长）</li>
</ul>
</li>
</ul>
</li>
<li>出现三种情况<ul>
<li>赢得多数的选票，成功选举为leader</li>
<li>收到了leader的消息，标识其他的服务器已经抢先当选了leader</li>
<li>没有服务器赢得多数的选票，leader选举失败，等待选举时间超时后发起下一次选举（随机超时）<br><img src="/2020/11/12/consul/raft-process.jpg" alt="raft-porcess">       </li>
</ul>
</li>
</ul>
<ol start="2">
<li>日志同步</li>
</ol>
<p>当Leader被选出来后，就可以接受客户端发来的请求了，每个请求包含一条需要被replicated state machines执行的命令。leader会把它作为一个log entry append到日志中，然后给其它的server发AppendEntriesRPC请求。当Leader确定一个log entry被safely replicated了（大多数副本已经将该命令写入日志当中），就apply这条log entry到状态机中然后返回结果给客户端。如果某个Follower宕机了或者运行的很慢，或者网络丢包了，则会一直给这个Follower发AppendEntriesRPC直到日志一致。</p>
<p>当一条日志是commited时，Leader才可以将它应用到状态机中。Raft保证一条commited的log entry已经持久化了并且会被所有的节点执行。<br><img src="/2020/11/12/consul/sync.jpg" alt="sync"></p>
<p>当一个新的Leader被选出来时，它的日志和其它的Follower的日志可能不一样，这个时候，就需要一个机制来保证日志的一致性。一个新leader产生时，集群状态可能如下：<br><img src="/2020/11/12/consul/leader-crash.jpg" alt="crash"><br>以leader和b为例：</p>
<p>初始化，nextIndex为11，leader给b发送AppendEntriesRPC(6,10)，b在自己log的10号槽位中没有找到term_id为6的log entry。则给leader回应一个拒绝消息。接着，leader将nextIndex减一，变成10，然后给b发送AppendEntriesRPC(6, 9)，b在自己log的9号槽位中同样没有找到term_id为6的log entry。循环下去，直到leader发送了AppendEntriesRPC(4,4)，b在自己log的槽位4中找到了term_id为4的log entry。接收了消息。随后，leader就可以从槽位5开始给b推送日志了。</p>
<ol start="3">
<li>安全性</li>
</ol>
<ul>
<li>拥有最新的已提交的log entry的Follower才有资格成为Leader。<blockquote>
<p>这个保证是在RequestVote RPC中做的，Candidate在发送RequestVote RPC时，要带上自己的最后一条日志的term和log index，其他节点收到消息时，如果&gt;现自己的日志比请求中携带的更新，则拒绝投票。日志比较的原则是，如果本地的最后一条log entry的term更大，则term大的更新，如果term一样大，则log index更大的更新。</p>
</blockquote>
</li>
<li>日志提交限制<blockquote>
<p>Leader只能推进commit index来提交当前term的已经复制到大多数服务器上的日志，旧term日志的提交要等到提交当前term的日志来间接提交（log index 小于 commit index的日志被间接提交）。</p>
</blockquote>
</li>
</ul>
<p><img src="/2020/11/12/consul/commit.png" alt="commit"></p>
<p>在阶段a，term为2，S1是Leader，且S1写入日志（term, index）为(2, 2)，并且日志被同步写入了S2；</p>
<p>在阶段b，S1离线，触发一次新的选主，此时S5被选为新的Leader，此时系统term为3，且写入了日志（term, index）为（3， 2）;</p>
<p>S5尚未将日志推送到Followers就离线了，进而触发了一次新的选主，而之前离线的S1经过重新上线后被选中变成Leader，此时系统term为4，此时S1会将自己的日志同步到Followers，按照上图就是将日志（2， 2）同步到了S3，而此时由于该日志已经被同步到了多数节点（S1, S2, S3），因此，此时日志（2，2）可以被提交了。；</p>
<p>在阶段d，S1又下线了，触发一次选主，而S5有可能被选为新的Leader（这是因为S5可以满足作为主的一切条件：1. term = 5 &gt; 4，2. 最新的日志为（3，2），比大多数节点（如S2/S3/S4的日志都新），然后S5会将自己的日志更新到Followers，于是S2、S3中已经被提交的日志（2，2）被截断了。</p>
<p>针对上述情况就是：即使日志（2，2）已经被大多数节点（S1、S2、S3）确认了，但是它不能被Commit，因为它是来自之前term(2)的日志，直到S1在当前term（4）产生的日志（4， 3）被大多数Follower确认，S1方可Commit（4，3）这条日志，当然，根据Raft定义，（4，3）之前的所有日志也会被Commit。此时即使S1再下线，重新选主时S5不可能成为Leader，因为它没有包含大多数节点已经拥有的日志（4，3）。</p>
]]></content>
      <categories>
        <category>consul</category>
      </categories>
      <tags>
        <tag>consul</tag>
      </tags>
  </entry>
  <entry>
    <title>spring Bean 的加载过程</title>
    <url>/2020/10/14/spring-bean-create/</url>
    <content><![CDATA[<h1 id="过程概览"><a href="#过程概览" class="headerlink" title="过程概览"></a>过程概览</h1><p>经过了对XML等配置文件的解析，获取resource后，将会开始进行bean的加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> doGetBean(name, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>整个doGetBean的全过程如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">			<span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// 先对beanName进行处理，如果有&amp;前缀，先去掉，后续紧跟着就是要去getSingleton 检查一把</span></span><br><span class="line">    <span class="keyword">final</span> String beanName = transformedBeanName(name);</span><br><span class="line">    Object bean;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尝试从缓存中加载单例</span></span><br><span class="line">    Object sharedInstance = getSingleton(beanName);</span><br><span class="line">    <span class="keyword">if</span> (sharedInstance != <span class="keyword">null</span> &amp;&amp; args == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Returning eagerly cached instance of singleton bean &#x27;&quot;</span> + beanName +</span><br><span class="line">                        <span class="string">&quot;&#x27; that is not fully initialized yet - a consequence of a circular reference&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Returning cached instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回beanName对应的实例，如果是factoryBean类型则返回其getObject的实例</span></span><br><span class="line">        <span class="comment">// 如果要返回factoryBean本实例，则需要在beanName前加上前缀&amp;</span></span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Fail if we&#x27;re already creating this bean instance:</span></span><br><span class="line">        <span class="comment">// We&#x27;re assumably within a circular reference.</span></span><br><span class="line">        <span class="comment">// 其中有一个线程变量类型的set存储，如果在一个线程中遇到一个正在创建中的bean，则说明遇到了循环依赖，直接报错</span></span><br><span class="line">        <span class="comment">// prototype类型 无法解决循环依赖</span></span><br><span class="line">        <span class="keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if bean definition exists in this factory.</span></span><br><span class="line">        BeanFactory parentBeanFactory = getParentBeanFactory();</span><br><span class="line">        <span class="comment">// 如果在当前beanDefinitionMap中没有找到，则去parent中找</span></span><br><span class="line">        <span class="keyword">if</span> (parentBeanFactory != <span class="keyword">null</span> &amp;&amp; !containsBeanDefinition(beanName)) &#123;</span><br><span class="line">            <span class="comment">// Not found -&gt; check parent.</span></span><br><span class="line">            String nameToLookup = originalBeanName(name);</span><br><span class="line">            <span class="keyword">if</span> (parentBeanFactory <span class="keyword">instanceof</span> AbstractBeanFactory) &#123; </span><br><span class="line">                <span class="keyword">return</span> ((AbstractBeanFactory) parentBeanFactory).doGetBean(</span><br><span class="line">                        nameToLookup, requiredType, args, typeCheckOnly);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (args != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Delegation to parent with explicit args.</span></span><br><span class="line">                <span class="keyword">return</span> (T) parentBeanFactory.getBean(nameToLookup, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// No args -&gt; delegate to standard getBean method.</span></span><br><span class="line">                <span class="keyword">return</span> parentBeanFactory.getBean(nameToLookup, requiredType);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不是仅仅做类型检查，则是要创建bean，这里需要记录一下</span></span><br><span class="line">        <span class="keyword">if</span> (!typeCheckOnly) &#123;</span><br><span class="line">            markBeanAsCreated(beanName);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 将存储xml配置文件的GernericBeanDefinition转换为RootBeanDefinition</span></span><br><span class="line">            <span class="comment">// 如果指定beanNam是子bean的话 同时会合并父类的相关属性</span></span><br><span class="line">            <span class="keyword">final</span> RootBeanDefinition mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">            checkMergedBeanDefinition(mbd, beanName, args);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Guarantee initialization of beans that the current bean depends on.</span></span><br><span class="line">            <span class="comment">// 处理有 depends-on配置或者注记的bean</span></span><br><span class="line">            String[] dependsOn = mbd.getDependsOn();</span><br><span class="line">            <span class="keyword">if</span> (dependsOn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String dep : dependsOn) &#123;</span><br><span class="line">                    <span class="comment">// 检测是否反向也依赖,如果循环依赖则报错</span></span><br><span class="line">                    <span class="keyword">if</span> (isDependent(beanName, dep)) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">&quot;Circular depends-on relationship between &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; and &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 将依赖记录下来</span></span><br><span class="line">                    registerDependentBean(dep, beanName);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">// 执行依赖对象的getBean过程，让依赖对象先加载</span></span><br><span class="line">                        getBean(dep);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbd.getResourceDescription(), beanName,</span><br><span class="line">                                <span class="string">&quot;&#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; depends on missing bean &#x27;&quot;</span> + dep + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是单例对象</span></span><br><span class="line">            <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">                sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                        <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                        <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                        <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                        destroySingleton(beanName);</span><br><span class="line">                        <span class="keyword">throw</span> ex;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">                <span class="comment">// 如果是factoryBean则获取其getObject对象</span></span><br><span class="line">                bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果是多例对象</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">                <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">                Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforePrototypeCreation(beanName);</span><br><span class="line">                    prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    afterPrototypeCreation(beanName);</span><br><span class="line">                &#125;</span><br><span class="line">                bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 指定scope上实例化bean</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                String scopeName = mbd.getScope();</span><br><span class="line">                <span class="keyword">final</span> Scope scope = <span class="keyword">this</span>.scopes.get(scopeName);</span><br><span class="line">                <span class="keyword">if</span> (scope == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;No Scope registered for scope name &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object scopedInstance = scope.get(beanName, () -&gt; &#123;</span><br><span class="line">                        beforePrototypeCreation(beanName);</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">finally</span> &#123;</span><br><span class="line">                            afterPrototypeCreation(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                    bean = getObjectForBeanInstance(scopedInstance, name, beanName, mbd);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">catch</span> (IllegalStateException ex) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Scope &#x27;&quot;</span> + scopeName + <span class="string">&quot;&#x27; is not active for the current thread; consider &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;defining a scoped proxy for this bean if you intend to refer to it from a singleton&quot;</span>,</span><br><span class="line">                            ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">            cleanupAfterBeanCreationFailure(beanName);</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查需要的类型是否符合bean的实际类型</span></span><br><span class="line">    <span class="keyword">if</span> (requiredType != <span class="keyword">null</span> &amp;&amp; !requiredType.isInstance(bean)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            T convertedBean = getTypeConverter().convertIfNecessary(bean, requiredType);</span><br><span class="line">            <span class="keyword">if</span> (convertedBean == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> convertedBean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (TypeMismatchException ex) &#123;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.debug(<span class="string">&quot;Failed to convert bean &#x27;&quot;</span> + name + <span class="string">&quot;&#x27; to required type &#x27;&quot;</span> +</span><br><span class="line">                        ClassUtils.getQualifiedName(requiredType) + <span class="string">&quot;&#x27;&quot;</span>, ex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanNotOfRequiredTypeException(name, requiredType, bean.getClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (T) bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="缓存中获取单例bean"><a href="#缓存中获取单例bean" class="headerlink" title="缓存中获取单例bean"></a>缓存中获取单例bean</h1><p>参见循环依赖一讲<br><a href="https://blog.yarwen.com/2020/10/15/spring-circle-ref/">https://blog.yarwen.com/2020/10/15/spring-circle-ref/</a></p>
<h1 id="从bean的实例中获取对象"><a href="#从bean的实例中获取对象" class="headerlink" title="从bean的实例中获取对象"></a>从bean的实例中获取对象</h1><p>此方法在获取到缓存后，或者创建后会执行调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">		Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果指定的是获取工厂实例(以&amp;前缀)，但是该bean的instance并不是FactoryBean 则类型验证不通过</span></span><br><span class="line">	<span class="keyword">if</span> (BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (beanInstance <span class="keyword">instanceof</span> NullBean) &#123;</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanIsNotAFactoryException(transformedBeanName(name), beanInstance.getClass());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now we have the bean instance, which may be a normal bean or a FactoryBean.</span></span><br><span class="line">	<span class="comment">// If it&#x27;s a FactoryBean, we use it to create a bean instance, unless the</span></span><br><span class="line">	<span class="comment">// caller actually wants a reference to the factory.</span></span><br><span class="line">	<span class="keyword">if</span> (!(beanInstance <span class="keyword">instanceof</span> FactoryBean) || BeanFactoryUtils.isFactoryDereference(name)) &#123;</span><br><span class="line">		<span class="keyword">return</span> beanInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Object object = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (mbd == <span class="keyword">null</span>) &#123;</span><br><span class="line">		object = getCachedObjectForFactoryBean(beanName);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">		<span class="comment">// Return bean instance from factory.</span></span><br><span class="line">		FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) beanInstance;</span><br><span class="line">		<span class="comment">// Caches object obtained from FactoryBean if it is a singleton.</span></span><br><span class="line">		<span class="keyword">if</span> (mbd == <span class="keyword">null</span> &amp;&amp; containsBeanDefinition(beanName)) &#123;</span><br><span class="line">			mbd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">boolean</span> synthetic = (mbd != <span class="keyword">null</span> &amp;&amp; mbd.isSynthetic());</span><br><span class="line">		object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="获取单例"><a href="#获取单例" class="headerlink" title="获取单例"></a>获取单例</h1><p>如果缓存中不存在，则从头开始加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, ObjectFactory&lt;?&gt; singletonFactory)</span> </span>&#123;</span><br><span class="line">		Assert.notNull(beanName, <span class="string">&quot;Bean name must not be null&quot;</span>);</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">			Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">			<span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">this</span>.singletonsCurrentlyInDestruction) &#123;</span><br><span class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationNotAllowedException(beanName,</span><br><span class="line">							<span class="string">&quot;Singleton bean creation not allowed while singletons of this factory are in destruction &quot;</span> +</span><br><span class="line">							<span class="string">&quot;(Do not request a bean from a BeanFactory in a destroy method implementation!)&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">					logger.debug(<span class="string">&quot;Creating shared instance of singleton bean &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				beforeSingletonCreation(beanName);</span><br><span class="line">				<span class="keyword">boolean</span> newSingleton = <span class="keyword">false</span>;</span><br><span class="line">				<span class="keyword">boolean</span> recordSuppressedExceptions = (<span class="keyword">this</span>.suppressedExceptions == <span class="keyword">null</span>);</span><br><span class="line">				<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">					<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					singletonObject = singletonFactory.getObject();</span><br><span class="line">					newSingleton = <span class="keyword">true</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">catch</span> &#123;</span><br><span class="line">                    <span class="comment">// ......</span></span><br><span class="line">                &#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">finally</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (recordSuppressedExceptions) &#123;</span><br><span class="line">						<span class="keyword">this</span>.suppressedExceptions = <span class="keyword">null</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					afterSingletonCreation(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (newSingleton) &#123;</span><br><span class="line">					addSingleton(beanName, singletonObject);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> singletonObject;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h1 id="准备创建bean"><a href="#准备创建bean" class="headerlink" title="准备创建bean"></a>准备创建bean</h1><p>接着上文的 singletonFactory.getObject() 中 执行createBean操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">		RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line">		<span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line">		<span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">        <span class="comment">// 根据设置的class属性或者根据className来解析Class</span></span><br><span class="line">		Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line">		<span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">			mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Prepare method overrides.</span></span><br><span class="line">        <span class="comment">// 对override属性进行标记和验证 如lookup-method，replace-method</span></span><br><span class="line">		mbdToUse.prepareMethodOverrides();</span><br><span class="line">		<span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">        Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">			<span class="keyword">return</span> beanInstance;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// ......</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理override属性"><a href="#处理override属性" class="headerlink" title="处理override属性"></a>处理override属性</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 主要还是validate  检查下重载的方法在目标类中是否存在</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">prepareMethodOverrides</span><span class="params">()</span> <span class="keyword">throws</span> BeanDefinitionValidationException </span>&#123;</span><br><span class="line">	<span class="comment">// Check that lookup methods exists.</span></span><br><span class="line">	<span class="keyword">if</span> (hasMethodOverrides()) &#123;</span><br><span class="line">		Set&lt;MethodOverride&gt; overrides = getMethodOverrides().getOverrides();</span><br><span class="line">		<span class="keyword">synchronized</span> (overrides) &#123;</span><br><span class="line">			<span class="keyword">for</span> (MethodOverride mo : overrides) &#123;</span><br><span class="line">				prepareMethodOverride(mo);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="实例化的前置处理"><a href="#实例化的前置处理" class="headerlink" title="实例化的前置处理"></a>实例化的前置处理</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 当经过前置处理后返回的结果如果不为空，那么会直接略过后续的Bean的创建而直接返回结果</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">resolveBeforeInstantiation</span><span class="params">(String beanName, RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">	Object bean = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">if</span> (!Boolean.FALSE.equals(mbd.beforeInstantiationResolved)) &#123;</span><br><span class="line">		<span class="comment">// Make sure bean class is actually resolved at this point.</span></span><br><span class="line">		<span class="keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;</span><br><span class="line">			Class&lt;?&gt; targetType = determineTargetType(beanName, mbd);</span><br><span class="line">			<span class="keyword">if</span> (targetType != <span class="keyword">null</span>) &#123;</span><br><span class="line">				bean = applyBeanPostProcessorsBeforeInstantiation(targetType, beanName);</span><br><span class="line">				<span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line">					bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		mbd.beforeInstantiationResolved = (bean != <span class="keyword">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>用户需要实现InstantiationAwareBeanPostProcessor接口中的方法</p>
<h1 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h1><p>参见循环依赖一讲<br><a href="https://blog.yarwen.com/2020/10/15/spring-circle-ref/">https://blog.yarwen.com/2020/10/15/spring-circle-ref/</a></p>
<h1 id="创建bean"><a href="#创建bean" class="headerlink" title="创建bean"></a>创建bean</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> <span class="meta">@Nullable</span> Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// 创建实例</span></span><br><span class="line">    instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="keyword">final</span> Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    Class&lt;?&gt; beanType = instanceWrapper.getWrappedClass();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (beanType != NullBean.class) &#123;</span><br><span class="line">        mbd.resolvedTargetType = beanType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allow post-processors to modify the merged bean definition.</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    applyMergedBeanDefinitionPostProcessors(mbd, beanType, beanName);</span><br><span class="line">    <span class="comment">//......    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Eagerly cache singletons to be able to resolve circular references</span></span><br><span class="line">    <span class="comment">// even when triggered by lifecycle interfaces like BeanFactoryAware.</span></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    <span class="comment">// singletonFactories.put(beanName, singletonFactory);</span></span><br><span class="line">    addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize the bean instance.</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);</span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">       <span class="comment">//......</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        Object earlySingletonReference = getSingleton(beanName, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (earlySingletonReference != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (exposedObject == bean) &#123;</span><br><span class="line">                exposedObject = earlySingletonReference;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;</span><br><span class="line">                String[] dependentBeans = getDependentBeans(beanName);</span><br><span class="line">                Set&lt;String&gt; actualDependentBeans = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);</span><br><span class="line">                <span class="keyword">for</span> (String dependentBean : dependentBeans) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;</span><br><span class="line">                        actualDependentBeans.add(dependentBean);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> BeanCurrentlyInCreationException(beanName,</span><br><span class="line">                            <span class="string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27; has been injected into other beans [&quot;</span> +</span><br><span class="line">                            StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +</span><br><span class="line">                            <span class="string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +</span><br><span class="line">                            <span class="string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Register bean as disposable.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        registerDisposableBeanIfNecessary(beanName, bean, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                mbd.getResourceDescription(), beanName, <span class="string">&quot;Invalid destruction signature&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="创建bean的实例"><a href="#创建bean的实例" class="headerlink" title="创建bean的实例"></a>创建bean的实例</h2><h2 id="记录创建bean的ObjectFactory"><a href="#记录创建bean的ObjectFactory" class="headerlink" title="记录创建bean的ObjectFactory"></a>记录创建bean的ObjectFactory</h2><h2 id="属性注入"><a href="#属性注入" class="headerlink" title="属性注入"></a>属性注入</h2><h2 id="初始化bean"><a href="#初始化bean" class="headerlink" title="初始化bean"></a>初始化bean</h2><h2 id="注册DisposableBean"><a href="#注册DisposableBean" class="headerlink" title="注册DisposableBean"></a>注册DisposableBean</h2>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
  <entry>
    <title>spring IOC 基础总览</title>
    <url>/2020/10/10/spring-ioc-base/</url>
    <content><![CDATA[<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>控制反转， 把原代码中需要实现的对象创建、依赖，反转给容器来帮忙实现。（DI 是IOC的一种实现方式）</p>
<blockquote>
<p>由容器控制程序之间的关系，而不是由代码直接控制<br>由于控制权由代码转向了容器，所以称为反转 (是责任的反转)</p>
</blockquote>
<a id="more"></a>
<h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><p>依赖注入， 对象不是从容器中查找它的依赖类，而是在容器实例化对象时主动将它依赖的类注入给它</p>
<blockquote>
<p>Note that it is generally better to rely on Dependency Injection<br>(“push” configuration) to configure application objects through setters<br>or constructors, rather than use any form of “pull” configuration like a<br>BeanFactory lookup.  （JNDI 就是一种依赖查找 DL）<br>注入方式:</p>
</blockquote>
<ol>
<li>手动:  <ul>
<li>property属性注入（需要set方法）</li>
<li>constructor-arg 构造方法注入</li>
</ul>
</li>
<li>自动:<ul>
<li>XML的自动 <ul>
<li>set方式: autowire=”” (byType根据set方法的类型来匹配,byName根据set方法中的参数名匹配),</li>
<li>构造方式: autowire=”constructor”</li>
</ul>
</li>
<li>注解 @autowired (可以没有set方法， 可以写在属性，set方法，构造方法上)</li>
</ul>
</li>
</ol>
<h1 id="IOC-容器"><a href="#IOC-容器" class="headerlink" title="IOC 容器"></a>IOC 容器</h1><h2 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h2><ul>
<li>实现BeanFactory接口的简单容器，只实现了容器的最基本功能</li>
<li>位于spring的bean包<h3 id="几个子接口"><a href="#几个子接口" class="headerlink" title="几个子接口"></a>几个子接口</h3></li>
</ul>
<ol>
<li>ListableBeanFactory: bean可列表化</li>
<li>HierarchiCalBeanFactory: bean 有继承关系的</li>
<li>AutoWireCapableBeanFactory: bean的自动装配规则<h3 id="代码说明"><a href="#代码说明" class="headerlink" title="代码说明"></a>代码说明</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  一个factoryBean 类型的bean， 如果直接用去getBean(id) 返回的为getObject的对象，</span></span><br><span class="line"><span class="comment">    *  如果用getBean(&amp;id) 返回的则为该 factoryBean 本bean</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    String FACTORY_BEAN_PREFIX = <span class="string">&quot;&amp;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据bean的名字去获在ioc容器中的bean实例</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据bean的名字和类型来获取bean实例</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(String name, Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 支持传入构造函数中的参数 (仅支持prototype的bean)</span></span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String name, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据类型来获取bean</span></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">getBean</span><span class="params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 待分析</span></span><br><span class="line">    &lt;T&gt; <span class="function">ObjectProvider&lt;T&gt; <span class="title">getBeanProvider</span><span class="params">(Class&lt;T&gt; requiredType)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 是否包含</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsBean</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return false 不能说明就是另外一种类型. 需要准确的进行判断</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">(String name)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="comment">// 检查名字和类型是否match</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取指定bean实例的类型</span></span><br><span class="line">    Class&lt;?&gt; getType(String name) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// todo 待分析</span></span><br><span class="line">    Class&lt;?&gt; getType(String name, <span class="keyword">boolean</span> allowFactoryBeanInit) <span class="keyword">throws</span> NoSuchBeanDefinitionException;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取别名</span></span><br><span class="line">    String[] getAliases(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
BeanFactory 只对IOC 容器的基本行为进行定义， 不决定bean是如何定义和加载的。 如何产生对象需要关注IOC 容器 ApplicationContext的实现类。<h3 id="核心类学习"><a href="#核心类学习" class="headerlink" title="核心类学习"></a>核心类学习</h3></li>
</ol>
<ul>
<li>DefaultListbaleBeanFactory<ul>
<li>整个bean加载的核心部分，是spring注册和加载bean的默认实现</li>
</ul>
</li>
<li>XmlBeanFactory <ul>
<li>继承自DefaultListableBeanFactory</li>
<li>定义了一个XmlBeanDefinitionReader</li>
<li>需要传入一个Resource类型 交给reader进行BeanDefinition的加载 reader.loadBeanDefinitions(resource)</li>
<li>新版本中已Deprecated  可以用更为通用的实现方式<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;beans.xml&quot;</span>);</span><br><span class="line">DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">reader.loadBeanDefinitions(res);</span><br></pre></td></tr></table></figure>


</li>
</ul>
</li>
</ul>
<h2 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h2><p>作为容器的高级形态存在，在简单容器的基础上， 增加了许多面向框架的特性，同时对应用环境做了许多适配。</p>
<ul>
<li>位于spring的context包中</li>
<li>继承了BeanFactory的各子接口</li>
<li>继承了MessageSource,ApplicationEventpublisher等接口</li>
<li>扩展了更多功能<ul>
<li>支持不同的信息源 （MessageSource）</li>
<li>访问资源 (ResourceLoader) ，可以从不同地方得到Bean的定义资源</li>
<li>支持应用事件 (ApplicationEventPublisher) ,这些事件和Bean的生命周期的结合便于对bean进行管理<h3 id="子类学习"><a href="#子类学习" class="headerlink" title="子类学习"></a>子类学习</h3></li>
</ul>
</li>
<li>FileSystemXmlApplicationContext<ul>
<li>继承自AbstractXmlApplicationContext</li>
<li>实现设置路径和执行referesh</li>
<li>从文件系统加载xml的bean定义资源 getResourceByPath</li>
</ul>
</li>
</ul>
<h2 id="BeanDefinition"><a href="#BeanDefinition" class="headerlink" title="BeanDefinition"></a>BeanDefinition</h2><p>通过定义BeanDefinition 来管理基于spring的应用中的各种对象以及他们之间的相互依赖关系，BD抽象了我们对bean的定义，是让容器起作用的主要数据类型。</p>
<ul>
<li>ioc 是管理对象依赖关系的</li>
<li>BD就是对依赖反转模式中管理的对象依赖关系的数据抽象</li>
<li>依赖反转功能都是围绕对这个BD的处理来完成的</li>
</ul>
<h1 id="IOC-初始化过程"><a href="#IOC-初始化过程" class="headerlink" title="IOC 初始化过程"></a>IOC 初始化过程</h1><p>由refresh()方法启动，启动主要包括BeanDefinition的Resource定位、载入和注册三个基本过程。</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">        <span class="comment">// Prepare this context for refreshing.</span></span><br><span class="line">        prepareRefresh();</span><br><span class="line">        <span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line">        ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">        <span class="comment">// Prepare the bean factory for use in this context.</span></span><br><span class="line">        prepareBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// .....</span></span><br><span class="line">        <span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></span><br><span class="line">        postProcessBeanFactory(beanFactory);</span><br><span class="line">        <span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line">        invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line">        <span class="comment">// Register bean processors that intercept bean creation.</span></span><br><span class="line">        registerBeanPostProcessors(beanFactory);</span><br><span class="line">        <span class="comment">// Initialize message source for this context.</span></span><br><span class="line">        initMessageSource();</span><br><span class="line">        <span class="comment">// Initialize event multicaster for this context.</span></span><br><span class="line">        initApplicationEventMulticaster();</span><br><span class="line">        <span class="comment">// Initialize other special beans in specific context subclasses.</span></span><br><span class="line">        onRefresh();</span><br><span class="line">        <span class="comment">// Check for listener beans and register them.</span></span><br><span class="line">        registerListeners();</span><br><span class="line">        <span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line">        finishBeanFactoryInitialization(beanFactory);</span><br><span class="line">        <span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">        finishRefresh();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">BeanDefinition的资源定位: </span><br><span class="line">![<span class="number">123</span>](spring-ioc-base/<span class="number">1.</span>png)</span><br><span class="line"></span><br><span class="line">由图可以看到是通过 obtainFreshBeanFactory() 来进行资源的加载调用，最终在AbstractBeanDefinitionReader中进行loadBeanDefinitions，通过getResources方法获取到Resource资源</span><br><span class="line"></span><br><span class="line">## BeanDefinition的载入和解析</span><br><span class="line">这个载入过程，相当于把定义的BeanDefinition在IOC容器中转化成一个spring内部表示的数据结构的过程；Ioc容器对Bean的管理和依赖注入功能的实现，是通过对其持有的BeanDefinition进行各种相关操作来完成的。</span><br><span class="line">最终一路loadBeanDefinition到 XmlBeanDefinitionReader中（如果是其他的加载方式，就是其他的reader）</span><br><span class="line">``` java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">        Document doc = doLoadDocument(inputSource, resource);</span><br><span class="line">        <span class="comment">// bd按照spring的bean语义要求进行解析并转化为容器内部数据结构</span></span><br><span class="line">        <span class="keyword">return</span> registerBeanDefinitions(doc, resource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</span><br><span class="line">    <span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</span><br><span class="line">    documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</span><br><span class="line">    <span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后一路进入到 DefaultBeanDefinitionDocumentReader中doRegisterBeanDefinitions的parseBeanDefinitions</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">processBeanDefinition</span><span class="params">(Element ele, BeanDefinitionParserDelegate delegate)</span> </span>&#123;</span><br><span class="line">	BeanDefinitionHolder bdHolder = delegate.parseBeanDefinitionElement(ele);</span><br><span class="line">	<span class="keyword">if</span> (bdHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">		bdHolder = delegate.decorateBeanDefinitionIfRequired(ele, bdHolder);</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// Register the final decorated instance.</span></span><br><span class="line">			BeanDefinitionReaderUtils.registerBeanDefinition(bdHolder, getReaderContext().getRegistry());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</span><br><span class="line">			getReaderContext().error(<span class="string">&quot;Failed to register bean definition with name &#x27;&quot;</span> +</span><br><span class="line">					bdHolder.getBeanName() + <span class="string">&quot;&#x27;&quot;</span>, ele, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// Send registration event.</span></span><br><span class="line">		getReaderContext().fireComponentRegistered(<span class="keyword">new</span> BeanComponentDefinition(bdHolder));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后 由 BeanDefinitionParserDelegate 进行解析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinitionHolder <span class="title">parseBeanDefinitionElement</span><span class="params">(Element ele, <span class="meta">@Nullable</span> BeanDefinition containingBean)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解析出来beanDefinition</span></span><br><span class="line">    AbstractBeanDefinition beanDefinition = parseBeanDefinitionElement(ele, beanName, containingBean);</span><br><span class="line">    <span class="comment">// 返回beanDefinitionHolder</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BeanDefinitionHolder(beanDefinition, beanName, aliasesArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="向IOC容器注册这些BeanDefinition"><a href="#向IOC容器注册这些BeanDefinition" class="headerlink" title="向IOC容器注册这些BeanDefinition"></a>向IOC容器注册这些BeanDefinition</h2><p>通过调用BeanDefinitionRegistry接口将bd向IOC容器进行注册<br>最终在DefaultListableBeanFactory 中注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</span><br><span class="line">    <span class="comment">// 进行validate</span></span><br><span class="line">    <span class="comment">// 对已有的oldDefinition 进行处理</span></span><br><span class="line">    <span class="comment">// 添加新的</span></span><br><span class="line">    <span class="keyword">this</span>.beanDefinitionMap.put(beanName, beanDefinition);</span><br><span class="line">	<span class="keyword">this</span>.beanDefinitionNames.add(beanName);</span><br><span class="line">	<span class="keyword">this</span>.manualSingletonNames.remove(beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完成了BeanDefinition的注册，就完成了IOC容器的初始化过程。这些bd都在beanDefinitionMap里被检索和使用，这些信息是容器建立依赖反转的基础。</p>
<h1 id="IOC容器的依赖注入"><a href="#IOC容器的依赖注入" class="headerlink" title="IOC容器的依赖注入"></a>IOC容器的依赖注入</h1><h2 id="bean生成"><a href="#bean生成" class="headerlink" title="bean生成"></a>bean生成</h2><p>容器的依赖注入发生在getBean时，如果设置了lazy-init为true，则在启动时会跳过系统的getBean， 交由用户的getBean时进行依赖注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//在referesh方法中的</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DefaultListableBeanFactory 中 如果不是lazy则加载 否则跳过</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">					Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">                    <span class="comment">// 如果是factorybean 可以通过&amp;方式获取到该factoryBean 而不是getObject</span></span><br><span class="line">					<span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line">						<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line">						<span class="keyword">boolean</span> isEagerInit;</span><br><span class="line">						<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">							isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">											((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">									getAccessControlContext());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">else</span> &#123;</span><br><span class="line">							isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">									((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">							getBean(beanName);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					getBean(beanName);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后再getBean后续方法中将会发生依赖注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// AbstractBeanFactory</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">T <span class="title">doGetBean</span><span class="params">(<span class="keyword">final</span> String name, <span class="meta">@Nullable</span> <span class="keyword">final</span> Class&lt;T&gt; requiredType,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="meta">@Nullable</span> <span class="keyword">final</span> Object[] args, <span class="keyword">boolean</span> typeCheckOnly)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (mbd.isSingleton()) &#123;</span><br><span class="line">        sharedInstance = getSingleton(beanName, () -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 创建出该bean</span></span><br><span class="line">                <span class="keyword">return</span> createBean(beanName, mbd, args);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">                <span class="comment">// Explicitly remove instance from singleton cache: It might have been put there</span></span><br><span class="line">                <span class="comment">// eagerly by the creation process, to allow for circular reference resolution.</span></span><br><span class="line">                <span class="comment">// Also remove any beans that received a temporary reference to the bean.</span></span><br><span class="line">                destroySingleton(beanName);</span><br><span class="line">                <span class="keyword">throw</span> ex;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        bean = getObjectForBeanInstance(sharedInstance, name, beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (mbd.isPrototype()) &#123;</span><br><span class="line">        <span class="comment">// It&#x27;s a prototype -&gt; create a new instance.</span></span><br><span class="line">        Object prototypeInstance = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            beforePrototypeCreation(beanName);</span><br><span class="line">            prototypeInstance = createBean(beanName, mbd, args);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            afterPrototypeCreation(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        bean = getObjectForBeanInstance(prototypeInstance, name, beanName, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后续调用过程<br><img src="/2020/10/10/spring-ioc-base/2.png" alt="123"><br>最终反射生成对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> BeanWrapper <span class="title">instantiateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    Object beanInstance;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 采用的策略为CglibSubclassingInstantiationStrategy</span></span><br><span class="line">    beanInstance = getInstantiationStrategy().instantiate(mbd, beanName, parent);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    BeanWrapper bw = <span class="keyword">new</span> BeanWrapperImpl(beanInstance);</span><br><span class="line">    initBeanWrapper(bw);</span><br><span class="line">    <span class="keyword">return</span> bw;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Constructor&lt;T&gt; ctor, Object... args)</span> <span class="keyword">throws</span> BeanInstantiationException </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">    <span class="keyword">return</span> (KotlinDetector.isKotlinType(ctor.getDeclaringClass()) ?</span><br><span class="line">            KotlinDelegate.instantiateClass(ctor, args) : ctor.newInstance(args));</span><br><span class="line">	<span class="comment">// ...	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AutoWired"><a href="#AutoWired" class="headerlink" title="AutoWired"></a>AutoWired</h2><p>对于bean中通过autowired依赖了其他的对象，则加载过程为<br>如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;teacher&quot;</span> <span class="attr">class</span>=<span class="string">&quot;beanFactory.Teacher&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;beanFactory.User&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;singleton&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/2020/10/10/spring-ioc-base/3.png" alt="123"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在AbstractAutowireCapableBeanFactory中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">populateBean</span><span class="params">(String beanName, RootBeanDefinition mbd, <span class="meta">@Nullable</span> BeanWrapper bw)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里是配置文件中的property</span></span><br><span class="line">    PropertyValues pvs = (mbd.hasPropertyValues() ? mbd.getPropertyValues() : <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||</span><br><span class="line">            mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">        MutablePropertyValues newPvs = <span class="keyword">new</span> MutablePropertyValues(pvs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by name if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;</span><br><span class="line">            autowireByName(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add property values based on autowire by type if applicable.</span></span><br><span class="line">        <span class="keyword">if</span> (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;</span><br><span class="line">            autowireByType(beanName, mbd, bw, newPvs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 指定的property被autowire的出来的替换掉了</span></span><br><span class="line">        pvs = newPvs;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// .....</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最终 在BeanWrapperImpl中 写入</span></span><br><span class="line">ReflectionUtils.makeAccessible(writeMethod);</span><br><span class="line">writeMethod.invoke(getWrappedInstance(), value);</span><br></pre></td></tr></table></figure>

<h1 id="ApplicationContext及Bean-初始化及销毁"><a href="#ApplicationContext及Bean-初始化及销毁" class="headerlink" title="ApplicationContext及Bean 初始化及销毁"></a>ApplicationContext及Bean 初始化及销毁</h1><h2 id="prepareBeanFactory"><a href="#prepareBeanFactory" class="headerlink" title="prepareBeanFactory"></a>prepareBeanFactory</h2><h2 id="Bean-声明周期"><a href="#Bean-声明周期" class="headerlink" title="Bean 声明周期"></a>Bean 声明周期</h2><ul>
<li>Bean实例的创建</li>
<li>为Bean实例设置属性</li>
<li>调用Bean的初始化方法</li>
<li>应用可以通过IOC容器使用Bean</li>
<li>当容器关闭时，调用bean的销毁方法<br>其中 调用bean的初始化方法如下：<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">    applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);</span><br><span class="line">    applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">//.....</span></span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">                (mbd != <span class="keyword">null</span> ? mbd.getResourceDescription() : <span class="keyword">null</span>),</span><br><span class="line">                beanName, <span class="string">&quot;Invocation of init method failed&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mbd == <span class="keyword">null</span> || !mbd.isSynthetic()) &#123;</span><br><span class="line">        wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrappedBean;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareMethods</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanNameAware) &#123;</span><br><span class="line">            ((BeanNameAware) bean).setBeanName(beanName);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanClassLoaderAware) &#123;</span><br><span class="line">            ClassLoader bcl = getBeanClassLoader();</span><br><span class="line">            <span class="keyword">if</span> (bcl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ((BeanClassLoaderAware) bean).setBeanClassLoader(bcl);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> BeanFactoryAware) &#123;</span><br><span class="line">            ((BeanFactoryAware) bean).setBeanFactory(AbstractAutowireCapableBeanFactory.<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="comment">// 如果继承了 InitializingBean 执行以下方法</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">                !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            <span class="comment">// 执行用户配置的bean的initMethod</span></span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="FactoryBean的实现"><a href="#FactoryBean的实现" class="headerlink" title="FactoryBean的实现"></a>FactoryBean的实现</h2><p>在初始化过程中，并不会初始化getObject中的对象，当用户getBean时才会初始化。<br>在getBean时，会进行转化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function">NamedBeanHolder&lt;T&gt; <span class="title">resolveNamedBean</span><span class="params">(Class&lt;T&gt; requiredType, <span class="meta">@Nullable</span> Object... args)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    String[] candidateNames = getBeanNamesForType(requiredType); </span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之后会在所有的beanDefinition中寻找匹配的factoryBean</span></span><br><span class="line"><span class="keyword">private</span> String[] doGetBeanNamesForType(ResolvableType type, <span class="keyword">boolean</span> includeNonSingletons, <span class="keyword">boolean</span> allowEagerInit) &#123;</span><br><span class="line">		List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Check all bean definitions.</span></span><br><span class="line">		<span class="keyword">for</span> (String beanName : <span class="keyword">this</span>.beanDefinitionNames) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> matchFound =</span><br><span class="line">                (allowEagerInit || !isFactoryBean ||</span><br><span class="line">                        (dbd != <span class="keyword">null</span> &amp;&amp; !mbd.isLazyInit()) || containsSingleton(beanName)) &amp;&amp;</span><br><span class="line">                (includeNonSingletons ||</span><br><span class="line">                        (dbd != <span class="keyword">null</span> ? mbd.isSingleton() : isSingleton(beanName))) &amp;&amp;</span><br><span class="line">                isTypeMatch(beanName, type);</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的比较方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTypeMatch</span><span class="params">(String name, ResolvableType typeToMatch)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException </span>&#123;</span><br><span class="line">		String beanName = transformedBeanName(name);</span><br><span class="line">    <span class="comment">//...		</span></span><br><span class="line">    Class&lt;?&gt; type = getTypeForFactoryBean((FactoryBean&lt;?&gt;) beanInstance); <span class="comment">//利用到了factory中的getObjectType</span></span><br><span class="line">    <span class="keyword">return</span> (type != <span class="keyword">null</span> &amp;&amp; typeToMatch.isAssignableFrom(type));</span><br><span class="line">    <span class="comment">// ...	</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后会在doGetBean中 进入到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getObjectForBeanInstance</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        Object beanInstance, String name, String beanName, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object = getObjectFromFactoryBean(factory, beanName, !synthetic);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 之后进入 object = doGetObjectFromFactoryBean(factory, beanName);</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">doGetObjectFromFactoryBean</span><span class="params">(<span class="keyword">final</span> FactoryBean&lt;?&gt; factory, <span class="keyword">final</span> String beanName)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object object;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    object = factory.getObject();</span><br><span class="line">    <span class="comment">// //</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h2><p> 该接口我们也叫后置处理器，作用是在Bean对象在实例化和依赖注入完毕后，在显示调用初始化方法的前后添加我们自己的逻辑。注意是Bean实例化完毕后及依赖注入完成后触发的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 在AbstractAutowireCapableBeanFactory 中 doCreateBean中</span></span><br><span class="line">populateBean(beanName, mbd, instanceWrapper);  <span class="comment">// 先实例化</span></span><br><span class="line">exposedObject = initializeBean(beanName, exposedObject, mbd);  <span class="comment">// 再执行BeanPostProcessor</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在initializeBean中</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">initializeBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeAwareMethods(beanName, bean);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">	applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    invokeInitMethods(beanName, wrappedBean, mbd);  <span class="comment">// before 和 after 这个方法</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现如下</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsBeforeInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessBeforeInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">applyBeanPostProcessorsAfterInitialization</span><span class="params">(Object existingBean, String beanName)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">    Object result = existingBean;</span><br><span class="line">    <span class="keyword">for</span> (BeanPostProcessor beanProcessor : getBeanPostProcessors()) &#123;</span><br><span class="line">        Object current = beanProcessor.postProcessAfterInitialization(result, beanName);</span><br><span class="line">        <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        result = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 而这两个方法前后包裹的 invokeInitMethods 如下</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, <span class="keyword">final</span> Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = (bean <span class="keyword">instanceof</span> InitializingBean);</span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">            <span class="comment">// 如果实现了InitializingBean 执行afterPropertiesSet</span></span><br><span class="line">            ((InitializingBean) bean).afterPropertiesSet();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp;</span><br><span class="line">                !(isInitializingBean &amp;&amp; <span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp;</span><br><span class="line">                !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">            <span class="comment">// 如果在bean里定义了initMethod</span></span><br><span class="line">            invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Bean-对IOC-容器的感知"><a href="#Bean-对IOC-容器的感知" class="headerlink" title="Bean 对IOC 容器的感知"></a>Bean 对IOC 容器的感知</h2><p>某些情况下，需要在Bean中直接对IOC容器进行操作，需要在Bean中设定对容器的感知。通过特定的aware接口来完成。</p>
<ul>
<li>BeanNameAware</li>
<li>BeanFactoryAware</li>
<li>ApplicationContextAware</li>
<li>MessageSourceAware</li>
<li>ApplicationEventPublisherAware</li>
<li>ResourceLoaderAware</li>
</ul>
<p>在ApplicationContextAwareProcessor中 执行了aware的调用postProcessBeforeInitialization</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeAwareInterfaces</span><span class="params">(Object bean)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> Aware) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EnvironmentAware) &#123;</span><br><span class="line">            ((EnvironmentAware) bean).setEnvironment(<span class="keyword">this</span>.applicationContext.getEnvironment());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> EmbeddedValueResolverAware) &#123;</span><br><span class="line">            ((EmbeddedValueResolverAware) bean).setEmbeddedValueResolver(<span class="keyword">this</span>.embeddedValueResolver);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ResourceLoaderAware) &#123;</span><br><span class="line">            ((ResourceLoaderAware) bean).setResourceLoader(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationEventPublisherAware) &#123;</span><br><span class="line">            ((ApplicationEventPublisherAware) bean).setApplicationEventPublisher(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> MessageSourceAware) &#123;</span><br><span class="line">            ((MessageSourceAware) bean).setMessageSource(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> ApplicationContextAware) &#123;</span><br><span class="line">            ((ApplicationContextAware) bean).setApplicationContext(<span class="keyword">this</span>.applicationContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
        <tag>ioc</tag>
      </tags>
  </entry>
</search>
